{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertUninitialized = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;\nconst stream_1 = require(\"stream\");\nconst bson_1 = require(\"../bson\");\nconst responses_1 = require(\"../cmap/wire_protocol/responses\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst get_more_1 = require(\"../operations/get_more\");\nconst kill_cursors_1 = require(\"../operations/kill_cursors\");\nconst read_concern_1 = require(\"../read_concern\");\nconst read_preference_1 = require(\"../read_preference\");\nconst sessions_1 = require(\"../sessions\");\nconst utils_1 = require(\"../utils\");\n/** @internal */\nconst kId = Symbol('id');\n/** @internal */\nconst kDocuments = Symbol('documents');\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kNamespace = Symbol('namespace');\n/** @internal */\nconst kClient = Symbol('client');\n/** @internal */\nconst kSession = Symbol('session');\n/** @internal */\nconst kOptions = Symbol('options');\n/** @internal */\nconst kTransform = Symbol('transform');\n/** @internal */\nconst kInitialized = Symbol('initialized');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kKilled = Symbol('killed');\n/** @internal */\nconst kInit = Symbol('kInit');\n/** @public */\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\n/** @public */\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n  /** @internal */\n  constructor(client, namespace) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    if (!client.s.isMongoClient) {\n      throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this[kClient] = client;\n    this[kNamespace] = namespace;\n    this[kId] = null;\n    this[kDocuments] = new utils_1.List();\n    this[kInitialized] = false;\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kOptions] = {\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options)\n    };\n    this[kOptions].timeoutMS = options.timeoutMS;\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this[kOptions].readConcern = readConcern;\n    }\n    if (typeof options.batchSize === 'number') {\n      this[kOptions].batchSize = options.batchSize;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this[kOptions].comment = options.comment;\n    }\n    if (typeof options.maxTimeMS === 'number') {\n      this[kOptions].maxTimeMS = options.maxTimeMS;\n    }\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this[kOptions].maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n    if (options.session instanceof sessions_1.ClientSession) {\n      this[kSession] = options.session;\n    } else {\n      this[kSession] = this[kClient].startSession({\n        owner: this,\n        explicit: false\n      });\n    }\n  }\n  get id() {\n    var _this$kId;\n    return (_this$kId = this[kId]) !== null && _this$kId !== void 0 ? _this$kId : undefined;\n  }\n  /** @internal */\n  get isDead() {\n    var _this$kId$isZero, _this$kId2;\n    return ((_this$kId$isZero = (_this$kId2 = this[kId]) === null || _this$kId2 === void 0 ? void 0 : _this$kId2.isZero()) !== null && _this$kId$isZero !== void 0 ? _this$kId$isZero : false) || this[kClosed] || this[kKilled];\n  }\n  /** @internal */\n  get client() {\n    return this[kClient];\n  }\n  /** @internal */\n  get server() {\n    return this[kServer];\n  }\n  get namespace() {\n    return this[kNamespace];\n  }\n  get readPreference() {\n    return this[kOptions].readPreference;\n  }\n  get readConcern() {\n    return this[kOptions].readConcern;\n  }\n  /** @internal */\n  get session() {\n    return this[kSession];\n  }\n  set session(clientSession) {\n    this[kSession] = clientSession;\n  }\n  /** @internal */\n  get cursorOptions() {\n    return this[kOptions];\n  }\n  get closed() {\n    return this[kClosed];\n  }\n  get killed() {\n    return this[kKilled];\n  }\n  get loadBalanced() {\n    var _this$kClient$topolog;\n    return !!((_this$kClient$topolog = this[kClient].topology) !== null && _this$kClient$topolog !== void 0 && _this$kClient$topolog.loadBalanced);\n  }\n  /** Returns current buffered documents length */\n  bufferedCount() {\n    return this[kDocuments].length;\n  }\n  /** Returns current buffered documents */\n  readBufferedDocuments(number) {\n    const bufferedDocs = [];\n    const documentsToRead = Math.min(number !== null && number !== void 0 ? number : this[kDocuments].length, this[kDocuments].length);\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this[kDocuments].shift(this[kOptions]);\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n    return bufferedDocs;\n  }\n  async *[Symbol.asyncIterator]() {\n    if (this.closed) {\n      return;\n    }\n    try {\n      while (true) {\n        const document = await this.next();\n        // Intentional strict null check, because users can map cursors to falsey values.\n        // We allow mapping to all values except for null.\n        // eslint-disable-next-line no-restricted-syntax\n        if (document === null) {\n          if (!this.closed) {\n            const message = 'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n            try {\n              await cleanupCursor(this, {\n                needsToEmitClosed: true\n              });\n            } catch (error) {\n              (0, utils_1.squashError)(error);\n            }\n            throw new error_1.MongoAPIError(message);\n          }\n          break;\n        }\n        yield document;\n        if (this[kId] === bson_1.Long.ZERO) {\n          // Cursor exhausted\n          break;\n        }\n      }\n    } finally {\n      // Only close the cursor if it has not already been closed. This finally clause handles\n      // the case when a user would break out of a for await of loop early.\n      if (!this.closed) {\n        try {\n          await this.close();\n        } catch (error) {\n          (0, utils_1.squashError)(error);\n        }\n      }\n    }\n  }\n  stream(options) {\n    if (options !== null && options !== void 0 && options.transform) {\n      const transform = options.transform;\n      const readable = new ReadableCursorStream(this);\n      const transformedStream = readable.pipe(new stream_1.Transform({\n        objectMode: true,\n        highWaterMark: 1,\n        transform(chunk, _, callback) {\n          try {\n            const transformed = transform(chunk);\n            callback(undefined, transformed);\n          } catch (err) {\n            callback(err);\n          }\n        }\n      }));\n      // Bubble errors to transformed stream, because otherwise no way\n      // to handle this error.\n      readable.on('error', err => transformedStream.emit('error', err));\n      return transformedStream;\n    }\n    return new ReadableCursorStream(this);\n  }\n  async hasNext() {\n    if (this[kId] === bson_1.Long.ZERO) {\n      return false;\n    }\n    if (this[kDocuments].length !== 0) {\n      return true;\n    }\n    return await next(this, {\n      blocking: true,\n      transform: false,\n      shift: false\n    });\n  }\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  async next() {\n    if (this[kId] === bson_1.Long.ZERO) {\n      throw new error_1.MongoCursorExhaustedError();\n    }\n    return await next(this, {\n      blocking: true,\n      transform: true,\n      shift: true\n    });\n  }\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  async tryNext() {\n    if (this[kId] === bson_1.Long.ZERO) {\n      throw new error_1.MongoCursorExhaustedError();\n    }\n    return await next(this, {\n      blocking: false,\n      transform: true,\n      shift: true\n    });\n  }\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\n   */\n  async forEach(iterator) {\n    if (typeof iterator !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    for await (const document of this) {\n      const result = iterator(document);\n      if (result === false) {\n        break;\n      }\n    }\n  }\n  async close() {\n    const needsToEmitClosed = !this[kClosed];\n    this[kClosed] = true;\n    await cleanupCursor(this, {\n      needsToEmitClosed\n    });\n  }\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   */\n  async toArray() {\n    const array = [];\n    for await (const document of this) {\n      array.push(document);\n    }\n    return array;\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag, value) {\n    assertUninitialized(this);\n    if (!exports.CURSOR_FLAGS.includes(flag)) {\n      throw new error_1.MongoInvalidArgumentError(\"Flag \".concat(flag, \" is not one of \").concat(exports.CURSOR_FLAGS));\n    }\n    if (typeof value !== 'boolean') {\n      throw new error_1.MongoInvalidArgumentError(\"Flag \".concat(flag, \" must be a boolean value\"));\n    }\n    this[kOptions][flag] = value;\n    return this;\n  }\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map(transform) {\n    assertUninitialized(this);\n    const oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing\n    if (oldTransform) {\n      this[kTransform] = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this[kTransform] = transform;\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference) {\n    assertUninitialized(this);\n    if (readPreference instanceof read_preference_1.ReadPreference) {\n      this[kOptions].readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    } else {\n      throw new error_1.MongoInvalidArgumentError(\"Invalid read preference: \".concat(readPreference));\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern) {\n    assertUninitialized(this);\n    const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n      readConcern\n    });\n    if (resolvedReadConcern) {\n      this[kOptions].readConcern = resolvedReadConcern;\n    }\n    return this;\n  }\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value) {\n    assertUninitialized(this);\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n    this[kOptions].maxTimeMS = value;\n    return this;\n  }\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value) {\n    assertUninitialized(this);\n    if (this[kOptions].tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n    this[kOptions].batchSize = value;\n    return this;\n  }\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind() {\n    if (!this[kInitialized]) {\n      return;\n    }\n    this[kId] = null;\n    this[kDocuments].clear();\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kInitialized] = false;\n    const session = this[kSession];\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false) {\n        if (!session.hasEnded) {\n          // eslint-disable-next-line github/no-then\n          session.endSession().then(undefined, utils_1.squashError);\n        }\n        this[kSession] = this.client.startSession({\n          owner: this,\n          explicit: false\n        });\n      }\n    }\n  }\n  /** @internal */\n  async getMore(batchSize) {\n    let useCursorResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const getMoreOperation = new get_more_1.GetMoreOperation(this[kNamespace], this[kId], this[kServer], {\n      ...this[kOptions],\n      session: this[kSession],\n      batchSize,\n      useCursorResponse\n    });\n    return await (0, execute_operation_1.executeOperation)(this[kClient], getMoreOperation);\n  }\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  async [kInit]() {\n    try {\n      const state = await this._initialize(this[kSession]);\n      const response = state.response;\n      this[kServer] = state.server;\n      if (responses_1.CursorResponse.is(response)) {\n        this[kId] = response.id;\n        if (response.ns) this[kNamespace] = response.ns;\n        this[kDocuments] = response;\n      } else if (response.cursor) {\n        // TODO(NODE-2674): Preserve int64 sent from MongoDB\n        this[kId] = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : typeof response.cursor.id === 'bigint' ? bson_1.Long.fromBigInt(response.cursor.id) : response.cursor.id;\n        if (response.cursor.ns) {\n          this[kNamespace] = (0, utils_1.ns)(response.cursor.ns);\n        }\n        this[kDocuments].pushMany(response.cursor.firstBatch);\n      }\n      // When server responses return without a cursor document, we close this cursor\n      // and return the raw server response. This is often the case for explain commands\n      // for example\n      if (this[kId] == null) {\n        this[kId] = bson_1.Long.ZERO;\n        // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n        this[kDocuments].push(state.response);\n      }\n      // the cursor is now initialized, even if it is dead\n      this[kInitialized] = true;\n    } catch (error) {\n      // the cursor is now initialized, even if an error occurred\n      this[kInitialized] = true;\n      await cleanupCursor(this, {\n        error\n      });\n      throw error;\n    }\n    if (this.isDead) {\n      await cleanupCursor(this, undefined);\n    }\n    return;\n  }\n}\n/** @event */\nAbstractCursor.CLOSE = 'close';\nexports.AbstractCursor = AbstractCursor;\nasync function next(cursor, _ref) {\n  let {\n    blocking,\n    transform,\n    shift\n  } = _ref;\n  if (cursor.closed) {\n    if (!shift) return false;\n    return null;\n  }\n  do {\n    if (cursor[kId] == null) {\n      // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n      await cursor[kInit]();\n    }\n    if (cursor[kDocuments].length !== 0) {\n      if (!shift) return true;\n      const doc = cursor[kDocuments].shift(cursor[kOptions]);\n      if (doc != null && transform && cursor[kTransform]) {\n        try {\n          return cursor[kTransform](doc);\n        } catch (error) {\n          try {\n            await cleanupCursor(cursor, {\n              error,\n              needsToEmitClosed: true\n            });\n          } catch (error) {\n            // `cleanupCursor` should never throw, squash and throw the original error\n            (0, utils_1.squashError)(error);\n          }\n          throw error;\n        }\n      }\n      return doc;\n    }\n    if (cursor.isDead) {\n      // if the cursor is dead, we clean it up\n      // cleanupCursor should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await cleanupCursor(cursor, {});\n      if (!shift) return false;\n      return null;\n    }\n    // otherwise need to call getMore\n    const batchSize = cursor[kOptions].batchSize || 1000;\n    try {\n      const response = await cursor.getMore(batchSize);\n      if (responses_1.CursorResponse.is(response)) {\n        cursor[kId] = response.id;\n        cursor[kDocuments] = response;\n      } else if (response) {\n        const cursorId = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : typeof response.cursor.id === 'bigint' ? bson_1.Long.fromBigInt(response.cursor.id) : response.cursor.id;\n        cursor[kDocuments].pushMany(response.cursor.nextBatch);\n        cursor[kId] = cursorId;\n      }\n    } catch (error) {\n      try {\n        await cleanupCursor(cursor, {\n          error,\n          needsToEmitClosed: true\n        });\n      } catch (error) {\n        // `cleanupCursor` should never throw, squash and throw the original error\n        (0, utils_1.squashError)(error);\n      }\n      throw error;\n    }\n    if (cursor.isDead) {\n      // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,\n      // we intentionally clean up the cursor to release its session back into the pool before the cursor\n      // is iterated.  This prevents a cursor that is exhausted on the server from holding\n      // onto a session indefinitely until the AbstractCursor is iterated.\n      //\n      // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await cleanupCursor(cursor, {});\n    }\n    if (cursor[kDocuments].length === 0 && blocking === false) {\n      if (!shift) return false;\n      return null;\n    }\n  } while (!cursor.isDead || cursor[kDocuments].length !== 0);\n  if (!shift) return false;\n  return null;\n}\nasync function cleanupCursor(cursor, options) {\n  var _options$needsToEmitC;\n  const cursorId = cursor[kId];\n  const cursorNs = cursor[kNamespace];\n  const server = cursor[kServer];\n  const session = cursor[kSession];\n  const error = options === null || options === void 0 ? void 0 : options.error;\n  // Cursors only emit closed events once the client-side cursor has been exhausted fully or there\n  // was an error.  Notably, when the server returns a cursor id of 0 and a non-empty batch, we\n  // cleanup the cursor but don't emit a `close` event.\n  const needsToEmitClosed = (_options$needsToEmitC = options === null || options === void 0 ? void 0 : options.needsToEmitClosed) !== null && _options$needsToEmitC !== void 0 ? _options$needsToEmitC : cursor[kDocuments].length === 0;\n  if (error) {\n    if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {\n      return await completeCleanup();\n    }\n  }\n  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n    if (needsToEmitClosed) {\n      cursor[kClosed] = true;\n      cursor[kId] = bson_1.Long.ZERO;\n      cursor.emit(AbstractCursor.CLOSE);\n    }\n    if (session) {\n      if (session.owner === cursor) {\n        await session.endSession({\n          error\n        });\n        return;\n      }\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n    }\n    return;\n  }\n  async function completeCleanup() {\n    if (session) {\n      if (session.owner === cursor) {\n        try {\n          await session.endSession({\n            error\n          });\n        } finally {\n          cursor.emit(AbstractCursor.CLOSE);\n        }\n        return;\n      }\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n    }\n    cursor.emit(AbstractCursor.CLOSE);\n    return;\n  }\n  cursor[kKilled] = true;\n  if (session.hasEnded) {\n    return await completeCleanup();\n  }\n  try {\n    await (0, execute_operation_1.executeOperation)(cursor[kClient], new kill_cursors_1.KillCursorsOperation(cursorId, cursorNs, server, {\n      session\n    }));\n  } catch (error) {\n    (0, utils_1.squashError)(error);\n  } finally {\n    await completeCleanup();\n  }\n}\n/** @internal */\nfunction assertUninitialized(cursor) {\n  if (cursor[kInitialized]) {\n    throw new error_1.MongoCursorInUseError();\n  }\n}\nexports.assertUninitialized = assertUninitialized;\nclass ReadableCursorStream extends stream_1.Readable {\n  constructor(cursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._readInProgress = false;\n    this._cursor = cursor;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _read(size) {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n  _destroy(error, callback) {\n    // eslint-disable-next-line github/no-then\n    this._cursor.close().then(() => callback(error), closeError => callback(closeError));\n  }\n  _readNext() {\n    // eslint-disable-next-line github/no-then\n    next(this._cursor, {\n      blocking: true,\n      transform: true,\n      shift: true\n    }).then(result => {\n      if (result == null) {\n        this.push(null);\n      } else if (this.destroyed) {\n        // eslint-disable-next-line github/no-then\n        this._cursor.close().then(undefined, utils_1.squashError);\n      } else {\n        if (this.push(result)) {\n          return this._readNext();\n        }\n        this._readInProgress = false;\n      }\n    }, err => {\n      // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n      //       desired behavior is that a stream ends cleanly when a user explicitly closes\n      //       a client during iteration. Alternatively, we could do the \"right\" thing and\n      //       propagate the error message by removing this special case.\n      if (err.message.match(/server is closed/)) {\n        // eslint-disable-next-line github/no-then\n        this._cursor.close().then(undefined, utils_1.squashError);\n        return this.push(null);\n      }\n      // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n      //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n      //       active getMore in-flight. This used to check if the cursor was killed but once\n      //       that changed to happen in cleanup legitimate errors would not destroy the\n      //       stream. There are change streams test specifically test these cases.\n      if (err.message.match(/operation was interrupted/)) {\n        return this.push(null);\n      }\n      // NOTE: The two above checks on the message of the error will cause a null to be pushed\n      //       to the stream, thus closing the stream before the destroy call happens. This means\n      //       that either of those error messages on a change stream will not get a proper\n      //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n      //       relies on that error event to be emitted to create its new cursor and thus was not\n      //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n      //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n      //       See NODE-4475.\n      return this.destroy(err);\n    });\n  }\n}","map":{"version":3,"names":["stream_1","require","bson_1","responses_1","error_1","mongo_types_1","execute_operation_1","get_more_1","kill_cursors_1","read_concern_1","read_preference_1","sessions_1","utils_1","kId","Symbol","kDocuments","kServer","kNamespace","kClient","kSession","kOptions","kTransform","kInitialized","kClosed","kKilled","kInit","exports","CURSOR_FLAGS","AbstractCursor","TypedEventEmitter","constructor","client","namespace","options","arguments","length","undefined","s","isMongoClient","MongoRuntimeError","List","readPreference","ReadPreference","primary","pluckBSONSerializeOptions","timeoutMS","readConcern","ReadConcern","fromOptions","batchSize","comment","maxTimeMS","maxAwaitTimeMS","session","ClientSession","startSession","owner","explicit","id","_this$kId","isDead","_this$kId$isZero","_this$kId2","isZero","server","clientSession","cursorOptions","closed","killed","loadBalanced","_this$kClient$topolog","topology","bufferedCount","readBufferedDocuments","number","bufferedDocs","documentsToRead","Math","min","count","document","shift","push","asyncIterator","next","message","cleanupCursor","needsToEmitClosed","error","squashError","MongoAPIError","Long","ZERO","close","stream","transform","readable","ReadableCursorStream","transformedStream","pipe","Transform","objectMode","highWaterMark","chunk","_","callback","transformed","err","on","emit","hasNext","blocking","MongoCursorExhaustedError","tryNext","forEach","iterator","MongoInvalidArgumentError","result","toArray","array","addCursorFlag","flag","value","assertUninitialized","includes","concat","map","oldTransform","doc","withReadPreference","fromString","withReadConcern","resolvedReadConcern","tailable","MongoTailableCursorError","rewind","clear","hasEnded","endSession","then","getMore","useCursorResponse","getMoreOperation","GetMoreOperation","executeOperation","state","_initialize","response","CursorResponse","is","ns","cursor","fromNumber","fromBigInt","pushMany","firstBatch","CLOSE","_ref","cursorId","nextBatch","_options$needsToEmitC","cursorNs","MongoNetworkError","completeCleanup","inTransaction","maybeClearPinnedConnection","KillCursorsOperation","MongoCursorInUseError","Readable","autoDestroy","_readInProgress","_cursor","_read","size","_readNext","_destroy","closeError","destroyed","match","destroy"],"sources":["/Users/Regan/Documents/GitHub/BadBank/node_modules/mongodb/src/cursor/abstract_cursor.ts"],"sourcesContent":["import { Readable, Transform } from 'stream';\n\nimport { type BSONSerializeOptions, type Document, Long, pluckBSONSerializeOptions } from '../bson';\nimport { CursorResponse } from '../cmap/wire_protocol/responses';\nimport {\n  type AnyError,\n  MongoAPIError,\n  MongoCursorExhaustedError,\n  MongoCursorInUseError,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoRuntimeError,\n  MongoTailableCursorError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { type TODO_NODE_3286, TypedEventEmitter } from '../mongo_types';\nimport { executeOperation, type ExecutionResult } from '../operations/execute_operation';\nimport { GetMoreOperation } from '../operations/get_more';\nimport { KillCursorsOperation } from '../operations/kill_cursors';\nimport { ReadConcern, type ReadConcernLike } from '../read_concern';\nimport { ReadPreference, type ReadPreferenceLike } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport { ClientSession, maybeClearPinnedConnection } from '../sessions';\nimport { List, type MongoDBNamespace, ns, squashError } from '../utils';\n\n/** @internal */\nconst kId = Symbol('id');\n/** @internal */\nconst kDocuments = Symbol('documents');\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kNamespace = Symbol('namespace');\n/** @internal */\nconst kClient = Symbol('client');\n/** @internal */\nconst kSession = Symbol('session');\n/** @internal */\nconst kOptions = Symbol('options');\n/** @internal */\nconst kTransform = Symbol('transform');\n/** @internal */\nconst kInitialized = Symbol('initialized');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kKilled = Symbol('killed');\n/** @internal */\nconst kInit = Symbol('kInit');\n\n/** @public */\nexport const CURSOR_FLAGS = [\n  'tailable',\n  'oplogReplay',\n  'noCursorTimeout',\n  'awaitData',\n  'exhaust',\n  'partial'\n] as const;\n\n/** @public */\nexport interface CursorStreamOptions {\n  /** A transformation method applied to each document emitted by the stream */\n  transform?(this: void, doc: Document): Document;\n}\n\n/** @public */\nexport type CursorFlag = (typeof CURSOR_FLAGS)[number];\n\n/** @public */\nexport interface AbstractCursorOptions extends BSONSerializeOptions {\n  session?: ClientSession;\n  readPreference?: ReadPreferenceLike;\n  readConcern?: ReadConcernLike;\n  /**\n   * Specifies the number of documents to return in each response from MongoDB\n   */\n  batchSize?: number;\n  /**\n   * When applicable `maxTimeMS` controls the amount of time the initial command\n   * that constructs a cursor should take. (ex. find, aggregate, listCollections)\n   */\n  maxTimeMS?: number;\n  /**\n   * When applicable `maxAwaitTimeMS` controls the amount of time subsequent getMores\n   * that a cursor uses to fetch more data should take. (ex. cursor.next())\n   */\n  maxAwaitTimeMS?: number;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n  /**\n   * By default, MongoDB will automatically close a cursor when the\n   * client has exhausted all results in the cursor. However, for [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections)\n   * you may use a Tailable Cursor that remains open after the client exhausts\n   * the results in the initial cursor.\n   */\n  tailable?: boolean;\n  /**\n   * If awaitData is set to true, when the cursor reaches the end of the capped collection,\n   * MongoDB blocks the query thread for a period of time waiting for new data to arrive.\n   * When new data is inserted into the capped collection, the blocked thread is signaled\n   * to wake up and return the next batch to the client.\n   */\n  awaitData?: boolean;\n  noCursorTimeout?: boolean;\n  /** @internal TODO(NODE-5688): make this public */\n  timeoutMS?: number;\n}\n\n/** @internal */\nexport type InternalAbstractCursorOptions = Omit<AbstractCursorOptions, 'readPreference'> & {\n  // resolved\n  readPreference: ReadPreference;\n  readConcern?: ReadConcern;\n\n  // cursor flags, some are deprecated\n  oplogReplay?: boolean;\n  exhaust?: boolean;\n  partial?: boolean;\n};\n\n/** @public */\nexport type AbstractCursorEvents = {\n  [AbstractCursor.CLOSE](): void;\n};\n\n/** @public */\nexport abstract class AbstractCursor<\n  TSchema = any,\n  CursorEvents extends AbstractCursorEvents = AbstractCursorEvents\n> extends TypedEventEmitter<CursorEvents> {\n  /** @internal */\n  [kId]: Long | null;\n  /** @internal */\n  [kSession]: ClientSession;\n  /** @internal */\n  [kServer]?: Server;\n  /** @internal */\n  [kNamespace]: MongoDBNamespace;\n  /** @internal */\n  [kDocuments]: {\n    length: number;\n    shift(bsonOptions?: any): TSchema | null;\n    clear(): void;\n    pushMany(many: Iterable<TSchema>): void;\n    push(item: TSchema): void;\n  };\n  /** @internal */\n  [kClient]: MongoClient;\n  /** @internal */\n  [kTransform]?: (doc: TSchema) => any;\n  /** @internal */\n  [kInitialized]: boolean;\n  /** @internal */\n  [kClosed]: boolean;\n  /** @internal */\n  [kKilled]: boolean;\n  /** @internal */\n  [kOptions]: InternalAbstractCursorOptions;\n\n  /** @event */\n  static readonly CLOSE = 'close' as const;\n\n  /** @internal */\n  constructor(\n    client: MongoClient,\n    namespace: MongoDBNamespace,\n    options: AbstractCursorOptions = {}\n  ) {\n    super();\n\n    if (!client.s.isMongoClient) {\n      throw new MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this[kClient] = client;\n    this[kNamespace] = namespace;\n    this[kId] = null;\n    this[kDocuments] = new List();\n    this[kInitialized] = false;\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kOptions] = {\n      readPreference:\n        options.readPreference && options.readPreference instanceof ReadPreference\n          ? options.readPreference\n          : ReadPreference.primary,\n      ...pluckBSONSerializeOptions(options)\n    };\n    this[kOptions].timeoutMS = options.timeoutMS;\n\n    const readConcern = ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this[kOptions].readConcern = readConcern;\n    }\n\n    if (typeof options.batchSize === 'number') {\n      this[kOptions].batchSize = options.batchSize;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this[kOptions].comment = options.comment;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      this[kOptions].maxTimeMS = options.maxTimeMS;\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this[kOptions].maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n\n    if (options.session instanceof ClientSession) {\n      this[kSession] = options.session;\n    } else {\n      this[kSession] = this[kClient].startSession({ owner: this, explicit: false });\n    }\n  }\n\n  get id(): Long | undefined {\n    return this[kId] ?? undefined;\n  }\n\n  /** @internal */\n  get isDead() {\n    return (this[kId]?.isZero() ?? false) || this[kClosed] || this[kKilled];\n  }\n\n  /** @internal */\n  get client(): MongoClient {\n    return this[kClient];\n  }\n\n  /** @internal */\n  get server(): Server | undefined {\n    return this[kServer];\n  }\n\n  get namespace(): MongoDBNamespace {\n    return this[kNamespace];\n  }\n\n  get readPreference(): ReadPreference {\n    return this[kOptions].readPreference;\n  }\n\n  get readConcern(): ReadConcern | undefined {\n    return this[kOptions].readConcern;\n  }\n\n  /** @internal */\n  get session(): ClientSession {\n    return this[kSession];\n  }\n\n  set session(clientSession: ClientSession) {\n    this[kSession] = clientSession;\n  }\n\n  /** @internal */\n  get cursorOptions(): InternalAbstractCursorOptions {\n    return this[kOptions];\n  }\n\n  get closed(): boolean {\n    return this[kClosed];\n  }\n\n  get killed(): boolean {\n    return this[kKilled];\n  }\n\n  get loadBalanced(): boolean {\n    return !!this[kClient].topology?.loadBalanced;\n  }\n\n  /** Returns current buffered documents length */\n  bufferedCount(): number {\n    return this[kDocuments].length;\n  }\n\n  /** Returns current buffered documents */\n  readBufferedDocuments(number?: number): TSchema[] {\n    const bufferedDocs: TSchema[] = [];\n    const documentsToRead = Math.min(number ?? this[kDocuments].length, this[kDocuments].length);\n\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this[kDocuments].shift(this[kOptions]);\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n\n    return bufferedDocs;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<TSchema, void, void> {\n    if (this.closed) {\n      return;\n    }\n\n    try {\n      while (true) {\n        const document = await this.next();\n\n        // Intentional strict null check, because users can map cursors to falsey values.\n        // We allow mapping to all values except for null.\n        // eslint-disable-next-line no-restricted-syntax\n        if (document === null) {\n          if (!this.closed) {\n            const message =\n              'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n\n            try {\n              await cleanupCursor(this, { needsToEmitClosed: true });\n            } catch (error) {\n              squashError(error);\n            }\n\n            throw new MongoAPIError(message);\n          }\n          break;\n        }\n\n        yield document;\n\n        if (this[kId] === Long.ZERO) {\n          // Cursor exhausted\n          break;\n        }\n      }\n    } finally {\n      // Only close the cursor if it has not already been closed. This finally clause handles\n      // the case when a user would break out of a for await of loop early.\n      if (!this.closed) {\n        try {\n          await this.close();\n        } catch (error) {\n          squashError(error);\n        }\n      }\n    }\n  }\n\n  stream(options?: CursorStreamOptions): Readable & AsyncIterable<TSchema> {\n    if (options?.transform) {\n      const transform = options.transform;\n      const readable = new ReadableCursorStream(this);\n\n      const transformedStream = readable.pipe(\n        new Transform({\n          objectMode: true,\n          highWaterMark: 1,\n          transform(chunk, _, callback) {\n            try {\n              const transformed = transform(chunk);\n              callback(undefined, transformed);\n            } catch (err) {\n              callback(err);\n            }\n          }\n        })\n      );\n\n      // Bubble errors to transformed stream, because otherwise no way\n      // to handle this error.\n      readable.on('error', err => transformedStream.emit('error', err));\n\n      return transformedStream;\n    }\n\n    return new ReadableCursorStream(this);\n  }\n\n  async hasNext(): Promise<boolean> {\n    if (this[kId] === Long.ZERO) {\n      return false;\n    }\n\n    if (this[kDocuments].length !== 0) {\n      return true;\n    }\n\n    return await next(this, { blocking: true, transform: false, shift: false });\n  }\n\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  async next(): Promise<TSchema | null> {\n    if (this[kId] === Long.ZERO) {\n      throw new MongoCursorExhaustedError();\n    }\n\n    return await next(this, { blocking: true, transform: true, shift: true });\n  }\n\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  async tryNext(): Promise<TSchema | null> {\n    if (this[kId] === Long.ZERO) {\n      throw new MongoCursorExhaustedError();\n    }\n\n    return await next(this, { blocking: false, transform: true, shift: true });\n  }\n\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\n   */\n  async forEach(iterator: (doc: TSchema) => boolean | void): Promise<void> {\n    if (typeof iterator !== 'function') {\n      throw new MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    for await (const document of this) {\n      const result = iterator(document);\n      if (result === false) {\n        break;\n      }\n    }\n  }\n\n  async close(): Promise<void> {\n    const needsToEmitClosed = !this[kClosed];\n    this[kClosed] = true;\n    await cleanupCursor(this, { needsToEmitClosed });\n  }\n\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   */\n  async toArray(): Promise<TSchema[]> {\n    const array = [];\n    for await (const document of this) {\n      array.push(document);\n    }\n    return array;\n  }\n\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag: CursorFlag, value: boolean): this {\n    assertUninitialized(this);\n    if (!CURSOR_FLAGS.includes(flag)) {\n      throw new MongoInvalidArgumentError(`Flag ${flag} is not one of ${CURSOR_FLAGS}`);\n    }\n\n    if (typeof value !== 'boolean') {\n      throw new MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n\n    this[kOptions][flag] = value;\n    return this;\n  }\n\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map<T = any>(transform: (doc: TSchema) => T): AbstractCursor<T> {\n    assertUninitialized(this);\n    const oldTransform = this[kTransform] as (doc: TSchema) => TSchema; // TODO(NODE-3283): Improve transform typing\n    if (oldTransform) {\n      this[kTransform] = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this[kTransform] = transform;\n    }\n\n    return this as unknown as AbstractCursor<T>;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference: ReadPreferenceLike): this {\n    assertUninitialized(this);\n    if (readPreference instanceof ReadPreference) {\n      this[kOptions].readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this[kOptions].readPreference = ReadPreference.fromString(readPreference);\n    } else {\n      throw new MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n\n    return this;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern: ReadConcernLike): this {\n    assertUninitialized(this);\n    const resolvedReadConcern = ReadConcern.fromOptions({ readConcern });\n    if (resolvedReadConcern) {\n      this[kOptions].readConcern = resolvedReadConcern;\n    }\n\n    return this;\n  }\n\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value: number): this {\n    assertUninitialized(this);\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n\n    this[kOptions].maxTimeMS = value;\n    return this;\n  }\n\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value: number): this {\n    assertUninitialized(this);\n    if (this[kOptions].tailable) {\n      throw new MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n\n    this[kOptions].batchSize = value;\n    return this;\n  }\n\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind(): void {\n    if (!this[kInitialized]) {\n      return;\n    }\n\n    this[kId] = null;\n    this[kDocuments].clear();\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kInitialized] = false;\n\n    const session = this[kSession];\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false) {\n        if (!session.hasEnded) {\n          // eslint-disable-next-line github/no-then\n          session.endSession().then(undefined, squashError);\n        }\n        this[kSession] = this.client.startSession({ owner: this, explicit: false });\n      }\n    }\n  }\n\n  /**\n   * Returns a new uninitialized copy of this cursor, with options matching those that have been set on the current instance\n   */\n  abstract clone(): AbstractCursor<TSchema>;\n\n  /** @internal */\n  protected abstract _initialize(session: ClientSession | undefined): Promise<ExecutionResult>;\n\n  /** @internal */\n  async getMore(batchSize: number, useCursorResponse = false): Promise<Document | null> {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const getMoreOperation = new GetMoreOperation(this[kNamespace], this[kId]!, this[kServer]!, {\n      ...this[kOptions],\n      session: this[kSession],\n      batchSize,\n      useCursorResponse\n    });\n\n    return await executeOperation(this[kClient], getMoreOperation);\n  }\n\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  async [kInit](): Promise<void> {\n    try {\n      const state = await this._initialize(this[kSession]);\n      const response = state.response;\n      this[kServer] = state.server;\n      if (CursorResponse.is(response)) {\n        this[kId] = response.id;\n        if (response.ns) this[kNamespace] = response.ns;\n        this[kDocuments] = response;\n      } else if (response.cursor) {\n        // TODO(NODE-2674): Preserve int64 sent from MongoDB\n        this[kId] =\n          typeof response.cursor.id === 'number'\n            ? Long.fromNumber(response.cursor.id)\n            : typeof response.cursor.id === 'bigint'\n            ? Long.fromBigInt(response.cursor.id)\n            : response.cursor.id;\n\n        if (response.cursor.ns) {\n          this[kNamespace] = ns(response.cursor.ns);\n        }\n\n        this[kDocuments].pushMany(response.cursor.firstBatch);\n      }\n\n      // When server responses return without a cursor document, we close this cursor\n      // and return the raw server response. This is often the case for explain commands\n      // for example\n      if (this[kId] == null) {\n        this[kId] = Long.ZERO;\n        // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n        this[kDocuments].push(state.response as TODO_NODE_3286);\n      }\n\n      // the cursor is now initialized, even if it is dead\n      this[kInitialized] = true;\n    } catch (error) {\n      // the cursor is now initialized, even if an error occurred\n      this[kInitialized] = true;\n      await cleanupCursor(this, { error });\n      throw error;\n    }\n\n    if (this.isDead) {\n      await cleanupCursor(this, undefined);\n    }\n\n    return;\n  }\n}\n\n/**\n * @param cursor - the cursor on which to call `next`\n * @param blocking - a boolean indicating whether or not the cursor should `block` until data\n *     is available.  Generally, this flag is set to `false` because if the getMore returns no documents,\n *     the cursor has been exhausted.  In certain scenarios (ChangeStreams, tailable await cursors and\n *     `tryNext`, for example) blocking is necessary because a getMore returning no documents does\n *     not indicate the end of the cursor.\n * @param transform - if true, the cursor's transform function is applied to the result document (if the transform exists)\n * @returns the next document in the cursor, or `null`.  When `blocking` is `true`, a `null` document means\n * the cursor has been exhausted.  Otherwise, it means that there is no document available in the cursor's buffer.\n */\nasync function next<T>(\n  cursor: AbstractCursor<T>,\n  {\n    blocking,\n    transform,\n    shift\n  }: {\n    blocking: boolean;\n    transform: boolean;\n    shift: false;\n  }\n): Promise<boolean>;\n\nasync function next<T>(\n  cursor: AbstractCursor<T>,\n  {\n    blocking,\n    transform,\n    shift\n  }: {\n    blocking: boolean;\n    transform: boolean;\n    shift: true;\n  }\n): Promise<T | null>;\n\nasync function next<T>(\n  cursor: AbstractCursor<T>,\n  {\n    blocking,\n    transform,\n    shift\n  }: {\n    blocking: boolean;\n    transform: boolean;\n    shift: boolean;\n  }\n): Promise<boolean | T | null> {\n  if (cursor.closed) {\n    if (!shift) return false;\n    return null;\n  }\n\n  do {\n    if (cursor[kId] == null) {\n      // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n      await cursor[kInit]();\n    }\n\n    if (cursor[kDocuments].length !== 0) {\n      if (!shift) return true;\n      const doc = cursor[kDocuments].shift(cursor[kOptions]);\n\n      if (doc != null && transform && cursor[kTransform]) {\n        try {\n          return cursor[kTransform](doc);\n        } catch (error) {\n          try {\n            await cleanupCursor(cursor, { error, needsToEmitClosed: true });\n          } catch (error) {\n            // `cleanupCursor` should never throw, squash and throw the original error\n            squashError(error);\n          }\n          throw error;\n        }\n      }\n\n      return doc;\n    }\n\n    if (cursor.isDead) {\n      // if the cursor is dead, we clean it up\n      // cleanupCursor should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await cleanupCursor(cursor, {});\n      if (!shift) return false;\n      return null;\n    }\n\n    // otherwise need to call getMore\n    const batchSize = cursor[kOptions].batchSize || 1000;\n\n    try {\n      const response = await cursor.getMore(batchSize);\n      if (CursorResponse.is(response)) {\n        cursor[kId] = response.id;\n        cursor[kDocuments] = response;\n      } else if (response) {\n        const cursorId =\n          typeof response.cursor.id === 'number'\n            ? Long.fromNumber(response.cursor.id)\n            : typeof response.cursor.id === 'bigint'\n            ? Long.fromBigInt(response.cursor.id)\n            : response.cursor.id;\n\n        cursor[kDocuments].pushMany(response.cursor.nextBatch);\n        cursor[kId] = cursorId;\n      }\n    } catch (error) {\n      try {\n        await cleanupCursor(cursor, { error, needsToEmitClosed: true });\n      } catch (error) {\n        // `cleanupCursor` should never throw, squash and throw the original error\n        squashError(error);\n      }\n      throw error;\n    }\n\n    if (cursor.isDead) {\n      // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,\n      // we intentionally clean up the cursor to release its session back into the pool before the cursor\n      // is iterated.  This prevents a cursor that is exhausted on the server from holding\n      // onto a session indefinitely until the AbstractCursor is iterated.\n      //\n      // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await cleanupCursor(cursor, {});\n    }\n\n    if (cursor[kDocuments].length === 0 && blocking === false) {\n      if (!shift) return false;\n      return null;\n    }\n  } while (!cursor.isDead || cursor[kDocuments].length !== 0);\n\n  if (!shift) return false;\n  return null;\n}\n\nasync function cleanupCursor(\n  cursor: AbstractCursor,\n  options: { error?: AnyError | undefined; needsToEmitClosed?: boolean } | undefined\n): Promise<void> {\n  const cursorId = cursor[kId];\n  const cursorNs = cursor[kNamespace];\n  const server = cursor[kServer];\n  const session = cursor[kSession];\n  const error = options?.error;\n\n  // Cursors only emit closed events once the client-side cursor has been exhausted fully or there\n  // was an error.  Notably, when the server returns a cursor id of 0 and a non-empty batch, we\n  // cleanup the cursor but don't emit a `close` event.\n  const needsToEmitClosed = options?.needsToEmitClosed ?? cursor[kDocuments].length === 0;\n\n  if (error) {\n    if (cursor.loadBalanced && error instanceof MongoNetworkError) {\n      return await completeCleanup();\n    }\n  }\n\n  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n    if (needsToEmitClosed) {\n      cursor[kClosed] = true;\n      cursor[kId] = Long.ZERO;\n      cursor.emit(AbstractCursor.CLOSE);\n    }\n\n    if (session) {\n      if (session.owner === cursor) {\n        await session.endSession({ error });\n        return;\n      }\n\n      if (!session.inTransaction()) {\n        maybeClearPinnedConnection(session, { error });\n      }\n    }\n\n    return;\n  }\n\n  async function completeCleanup() {\n    if (session) {\n      if (session.owner === cursor) {\n        try {\n          await session.endSession({ error });\n        } finally {\n          cursor.emit(AbstractCursor.CLOSE);\n        }\n        return;\n      }\n\n      if (!session.inTransaction()) {\n        maybeClearPinnedConnection(session, { error });\n      }\n    }\n\n    cursor.emit(AbstractCursor.CLOSE);\n    return;\n  }\n\n  cursor[kKilled] = true;\n\n  if (session.hasEnded) {\n    return await completeCleanup();\n  }\n\n  try {\n    await executeOperation(\n      cursor[kClient],\n      new KillCursorsOperation(cursorId, cursorNs, server, { session })\n    );\n  } catch (error) {\n    squashError(error);\n  } finally {\n    await completeCleanup();\n  }\n}\n\n/** @internal */\nexport function assertUninitialized(cursor: AbstractCursor): void {\n  if (cursor[kInitialized]) {\n    throw new MongoCursorInUseError();\n  }\n}\n\nclass ReadableCursorStream extends Readable {\n  private _cursor: AbstractCursor;\n  private _readInProgress = false;\n\n  constructor(cursor: AbstractCursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._cursor = cursor;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  override _read(size: number): void {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n\n  override _destroy(error: Error | null, callback: (error?: Error | null) => void): void {\n    // eslint-disable-next-line github/no-then\n    this._cursor.close().then(\n      () => callback(error),\n      closeError => callback(closeError)\n    );\n  }\n\n  private _readNext() {\n    // eslint-disable-next-line github/no-then\n    next(this._cursor, { blocking: true, transform: true, shift: true }).then(\n      result => {\n        if (result == null) {\n          this.push(null);\n        } else if (this.destroyed) {\n          // eslint-disable-next-line github/no-then\n          this._cursor.close().then(undefined, squashError);\n        } else {\n          if (this.push(result)) {\n            return this._readNext();\n          }\n\n          this._readInProgress = false;\n        }\n      },\n      err => {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          // eslint-disable-next-line github/no-then\n          this._cursor.close().then(undefined, squashError);\n          return this.push(null);\n        }\n\n        // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight. This used to check if the cursor was killed but once\n        //       that changed to happen in cleanup legitimate errors would not destroy the\n        //       stream. There are change streams test specifically test these cases.\n        if (err.message.match(/operation was interrupted/)) {\n          return this.push(null);\n        }\n\n        // NOTE: The two above checks on the message of the error will cause a null to be pushed\n        //       to the stream, thus closing the stream before the destroy call happens. This means\n        //       that either of those error messages on a change stream will not get a proper\n        //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n        //       relies on that error event to be emitted to create its new cursor and thus was not\n        //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n        //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n        //       See NODE-4475.\n        return this.destroy(err);\n      }\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}