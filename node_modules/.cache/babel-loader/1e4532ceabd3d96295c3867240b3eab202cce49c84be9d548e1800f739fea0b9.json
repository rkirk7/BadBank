{"ast":null,"code":"\"use strict\";\n\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\nconst bson_1 = require(\"./bson\");\nconst metrics_1 = require(\"./cmap/metrics\");\nconst shared_1 = require(\"./cmap/wire_protocol/shared\");\nconst constants_1 = require(\"./constants\");\nconst error_1 = require(\"./error\");\nconst mongo_types_1 = require(\"./mongo_types\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst run_command_1 = require(\"./operations/run_command\");\nconst read_concern_1 = require(\"./read_concern\");\nconst read_preference_1 = require(\"./read_preference\");\nconst common_1 = require(\"./sdam/common\");\nconst transactions_1 = require(\"./transactions\");\nconst utils_1 = require(\"./utils\");\nconst write_concern_1 = require(\"./write_concern\");\nconst minWireVersionForShardedTransactions = 8;\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nconst kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nclass ClientSession extends mongo_types_1.TypedEventEmitter {\n  /**\n   * Create a client session.\n   * @internal\n   * @param client - The current client\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(client, sessionPool, options, clientOptions) {\n    var _options, _options$defaultTimeo, _client$options, _options$causalConsis;\n    super();\n    /** @internal */\n    this[_a] = false;\n    if (client == null) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');\n    }\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n    options = (_options = options) !== null && _options !== void 0 ? _options : {};\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n      if (options.causalConsistency === true) {\n        throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n      }\n    }\n    this.client = client;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this.timeoutMS = (_options$defaultTimeo = options.defaultTimeoutMS) !== null && _options$defaultTimeo !== void 0 ? _options$defaultTimeo : (_client$options = client.options) === null || _client$options === void 0 ? void 0 : _client$options.timeoutMS;\n    this.explicit = !!options.explicit;\n    this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\n    this[kTxnNumberIncrement] = 0;\n    const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;\n    this.supports = {\n      // if we can enable causal consistency, do so by default\n      causalConsistency: (_options$causalConsis = options.causalConsistency) !== null && _options$causalConsis !== void 0 ? _options$causalConsis : defaultCausalConsistencyValue\n    };\n    this.clusterTime = options.initialClusterTime;\n    this.operationTime = undefined;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = {\n      ...options.defaultTransactionOptions\n    };\n    this.transaction = new transactions_1.Transaction();\n  }\n  /** The server id associated with this session */\n  get id() {\n    var _this$kServerSession;\n    return (_this$kServerSession = this[kServerSession]) === null || _this$kServerSession === void 0 ? void 0 : _this$kServerSession.id;\n  }\n  get serverSession() {\n    let serverSession = this[kServerSession];\n    if (serverSession == null) {\n      if (this.explicit) {\n        throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');\n      }\n      if (this.hasEnded) {\n        throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n      }\n      serverSession = this.sessionPool.acquire();\n      this[kServerSession] = serverSession;\n    }\n    return serverSession;\n  }\n  /** Whether or not this session is configured for snapshot reads */\n  get snapshotEnabled() {\n    return this[kSnapshotEnabled];\n  }\n  get loadBalanced() {\n    var _this$client$topology;\n    return ((_this$client$topology = this.client.topology) === null || _this$client$topology === void 0 ? void 0 : _this$client$topology.description.type) === common_1.TopologyType.LoadBalanced;\n  }\n  /** @internal */\n  get pinnedConnection() {\n    return this[kPinnedConnection];\n  }\n  /** @internal */\n  pin(conn) {\n    if (this[kPinnedConnection]) {\n      throw TypeError('Cannot pin multiple connections to the same session');\n    }\n    this[kPinnedConnection] = conn;\n    conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n  }\n  /** @internal */\n  unpin(options) {\n    if (this.loadBalanced) {\n      return maybeClearPinnedConnection(this, options);\n    }\n    this.transaction.unpinServer();\n  }\n  get isPinned() {\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n  }\n  /**\n   * Ends this session on the server\n   *\n   * @param options - Optional settings. Currently reserved for future use\n   */\n  async endSession(options) {\n    try {\n      if (this.inTransaction()) {\n        await this.abortTransaction();\n      }\n      if (!this.hasEnded) {\n        const serverSession = this[kServerSession];\n        if (serverSession != null) {\n          // release the server session back to the pool\n          this.sessionPool.release(serverSession);\n          // Make sure a new serverSession never makes it onto this ClientSession\n          Object.defineProperty(this, kServerSession, {\n            value: ServerSession.clone(serverSession),\n            writable: false\n          });\n        }\n        // mark the session as ended, and emit a signal\n        this.hasEnded = true;\n        this.emit('ended', this);\n      }\n    } catch (error) {\n      // spec indicates that we should ignore all errors for `endSessions`\n      (0, utils_1.squashError)(error);\n    } finally {\n      maybeClearPinnedConnection(this, {\n        force: true,\n        ...options\n      });\n    }\n  }\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n  /**\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n   *\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n   */\n  advanceClusterTime(clusterTime) {\n    var _clusterTime$signatur, _clusterTime$signatur2;\n    if (!clusterTime || typeof clusterTime !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n    }\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n    }\n    if (!clusterTime.signature || ((_clusterTime$signatur = clusterTime.signature.hash) === null || _clusterTime$signatur === void 0 ? void 0 : _clusterTime$signatur._bsontype) !== 'Binary' || typeof clusterTime.signature.keyId !== 'bigint' && typeof clusterTime.signature.keyId !== 'number' && ((_clusterTime$signatur2 = clusterTime.signature.keyId) === null || _clusterTime$signatur2 === void 0 ? void 0 : _clusterTime$signatur2._bsontype) !== 'Long' // apparently we decode the key to number?\n    ) {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n    }\n    (0, common_1._advanceClusterTime)(this, clusterTime);\n  }\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n    return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);\n  }\n  /**\n   * Increment the transaction number on the internal ServerSession\n   *\n   * @privateRemarks\n   * This helper increments a value stored on the client session that will be\n   * added to the serverSession's txnNumber upon applying it to a command.\n   * This is because the serverSession is lazily acquired after a connection is obtained\n   */\n  incrementTransactionNumber() {\n    this[kTxnNumberIncrement] += 1;\n  }\n  /** @returns whether this session is currently in a transaction or not */\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @remarks\n   * **IMPORTANT**: Running operations in parallel is not supported during a transaction. The use of `Promise.all`,\n   * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is\n   * undefined behaviour.\n   *\n   * @param options - Options for the transaction\n   */\n  startTransaction(options) {\n    var _ref, _options$readConcern, _this$clientOptions, _ref2, _options$writeConcern, _this$clientOptions2, _ref3, _options$readPreferen, _this$clientOptions3, _options$maxCommitTim;\n    if (this[kSnapshotEnabled]) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported in snapshot sessions');\n    }\n    if (this.inTransaction()) {\n      throw new error_1.MongoTransactionError('Transaction already in progress');\n    }\n    if (this.isPinned && this.transaction.isCommitted) {\n      this.unpin();\n    }\n    const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);\n    if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    }\n    // increment txnNumber\n    this.incrementTransactionNumber();\n    // create transaction state\n    this.transaction = new transactions_1.Transaction({\n      readConcern: (_ref = (_options$readConcern = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _options$readConcern !== void 0 ? _options$readConcern : this.defaultTransactionOptions.readConcern) !== null && _ref !== void 0 ? _ref : (_this$clientOptions = this.clientOptions) === null || _this$clientOptions === void 0 ? void 0 : _this$clientOptions.readConcern,\n      writeConcern: (_ref2 = (_options$writeConcern = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _options$writeConcern !== void 0 ? _options$writeConcern : this.defaultTransactionOptions.writeConcern) !== null && _ref2 !== void 0 ? _ref2 : (_this$clientOptions2 = this.clientOptions) === null || _this$clientOptions2 === void 0 ? void 0 : _this$clientOptions2.writeConcern,\n      readPreference: (_ref3 = (_options$readPreferen = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _options$readPreferen !== void 0 ? _options$readPreferen : this.defaultTransactionOptions.readPreference) !== null && _ref3 !== void 0 ? _ref3 : (_this$clientOptions3 = this.clientOptions) === null || _this$clientOptions3 === void 0 ? void 0 : _this$clientOptions3.readPreference,\n      maxCommitTimeMS: (_options$maxCommitTim = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _options$maxCommitTim !== void 0 ? _options$maxCommitTim : this.defaultTransactionOptions.maxCommitTimeMS\n    });\n    this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n  }\n  /**\n   * Commits the currently active transaction in this session.\n   */\n  async commitTransaction() {\n    return await endTransaction(this, 'commitTransaction');\n  }\n  /**\n   * Aborts the currently active transaction in this session.\n   */\n  async abortTransaction() {\n    return await endTransaction(this, 'abortTransaction');\n  }\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n  toBSON() {\n    throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n  }\n  /**\n   * Starts a transaction and runs a provided function, ensuring the commitTransaction is always attempted when all operations run in the function have completed.\n   *\n   * **IMPORTANT:** This method requires the function passed in to return a Promise. That promise must be made by `await`-ing all operations in such a way that rejections are propagated to the returned promise.\n   *\n   * **IMPORTANT:** Running operations in parallel is not supported during a transaction. The use of `Promise.all`,\n   * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is\n   * undefined behaviour.\n   *\n   *\n   * @remarks\n   * - If all operations successfully complete and the `commitTransaction` operation is successful, then the provided function will return the result of the provided function.\n   * - If the transaction is unable to complete or an error is thrown from within the provided function, then the provided function will throw an error.\n   *   - If the transaction is manually aborted within the provided function it will not throw.\n   * - If the driver needs to attempt to retry the operations, the provided function may be called multiple times.\n   *\n   * Checkout a descriptive example here:\n   * @see https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions\n   *\n   * If a command inside withTransaction fails:\n   * - It may cause the transaction on the server to be aborted.\n   * - This situation is normally handled transparently by the driver.\n   * - However, if the application catches such an error and does not rethrow it, the driver will not be able to determine whether the transaction was aborted or not.\n   * - The driver will then retry the transaction indefinitely.\n   *\n   * To avoid this situation, the application must not silently handle errors within the provided function.\n   * If the application needs to handle errors within, it must await all operations such that if an operation is rejected it becomes the rejection of the callback function passed into withTransaction.\n   *\n   * @param fn - callback to run within a transaction\n   * @param options - optional settings for the transaction\n   * @returns A raw command response or undefined\n   */\n  async withTransaction(fn, options) {\n    const startTime = (0, utils_1.now)();\n    return await attemptTransaction(this, startTime, fn, options);\n  }\n}\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\nfunction hasNotTimedOut(startTime, max) {\n  return (0, utils_1.calculateDurationInMs)(startTime) < max;\n}\nfunction isUnknownTransactionCommitResult(err) {\n  const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;\n}\nfunction maybeClearPinnedConnection(session, options) {\n  // unpin a connection if it has been pinned\n  const conn = session[kPinnedConnection];\n  const error = options === null || options === void 0 ? void 0 : options.error;\n  if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n    return;\n  }\n  const topology = session.client.topology;\n  // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n  if (conn && topology != null) {\n    const servers = Array.from(topology.s.servers.values());\n    const loadBalancer = servers[0];\n    if ((options === null || options === void 0 ? void 0 : options.error) == null || options !== null && options !== void 0 && options.force) {\n      loadBalancer.pool.checkIn(conn);\n      session[kPinnedConnection] = undefined;\n      conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n      if (options !== null && options !== void 0 && options.forceClear) {\n        loadBalancer.pool.clear({\n          serviceId: conn.serviceId\n        });\n      }\n    }\n  }\n}\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null || !(err instanceof error_1.MongoServerError)) {\n    return false;\n  }\n  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n}\nasync function attemptTransactionCommit(session, startTime, fn, result, options) {\n  try {\n    await session.commitTransaction();\n    return result;\n  } catch (commitErr) {\n    if (commitErr instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(commitErr)) {\n      if (commitErr.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {\n        return await attemptTransactionCommit(session, startTime, fn, result, options);\n      }\n      if (commitErr.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        return await attemptTransaction(session, startTime, fn, options);\n      }\n    }\n    throw commitErr;\n  }\n}\nconst USER_EXPLICIT_TXN_END_STATES = new Set([transactions_1.TxnState.NO_TRANSACTION, transactions_1.TxnState.TRANSACTION_COMMITTED, transactions_1.TxnState.TRANSACTION_ABORTED]);\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\nasync function attemptTransaction(session, startTime, fn) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  session.startTransaction(options);\n  let promise;\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n  if (!(0, utils_1.isPromiseLike)(promise)) {\n    try {\n      await session.abortTransaction();\n    } catch (error) {\n      (0, utils_1.squashError)(error);\n    }\n    throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');\n  }\n  try {\n    const result = await promise;\n    if (userExplicitlyEndedTransaction(session)) {\n      return result;\n    }\n    return await attemptTransactionCommit(session, startTime, fn, result, options);\n  } catch (err) {\n    if (session.inTransaction()) {\n      await session.abortTransaction();\n    }\n    if (err instanceof error_1.MongoError && err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n      return await attemptTransaction(session, startTime, fn, options);\n    }\n    if (isMaxTimeMSExpiredError(err)) {\n      err.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n    }\n    throw err;\n  }\n}\nasync function endTransaction(session, commandName) {\n  // handle any initial problematic cases\n  const txnState = session.transaction.state;\n  if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n    throw new error_1.MongoTransactionError('No transaction started');\n  }\n  if (commandName === 'commitTransaction') {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      throw new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction');\n    }\n  } else {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      throw new error_1.MongoTransactionError('Cannot call abortTransaction twice');\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      throw new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction');\n    }\n  }\n  // construct and send the command\n  const command = {\n    [commandName]: 1\n  };\n  // apply a writeConcern if specified\n  let writeConcern;\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = {\n      w: session.clientOptions.writeConcern.w\n    };\n  }\n  if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeoutMS: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n  if (writeConcern) {\n    write_concern_1.WriteConcern.apply(command, writeConcern);\n  }\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  }\n  try {\n    // send the command\n    await (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(command, {\n      session,\n      readPreference: read_preference_1.ReadPreference.primary,\n      bypassPinningCheck: true\n    }));\n    if (command.abortTransaction) {\n      // always unpin on abort regardless of command outcome\n      session.unpin();\n    }\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, {\n          force: false\n        });\n      }\n    } else {\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n    }\n  } catch (firstAttemptErr) {\n    if (command.abortTransaction) {\n      // always unpin on abort regardless of command outcome\n      session.unpin();\n    }\n    if (firstAttemptErr instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(firstAttemptErr)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.unpin({\n          force: true\n        });\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n      try {\n        await (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(command, {\n          session,\n          readPreference: read_preference_1.ReadPreference.primary,\n          bypassPinningCheck: true\n        }));\n        if (commandName !== 'commitTransaction') {\n          session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n          if (session.loadBalanced) {\n            maybeClearPinnedConnection(session, {\n              force: false\n            });\n          }\n        } else {\n          session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n        }\n      } catch (secondAttemptErr) {\n        handleEndTransactionError(session, commandName, secondAttemptErr);\n      }\n    } else {\n      handleEndTransactionError(session, commandName, firstAttemptErr);\n    }\n  }\n}\nfunction handleEndTransactionError(session, commandName, error) {\n  if (commandName !== 'commitTransaction') {\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n    if (session.loadBalanced) {\n      maybeClearPinnedConnection(session, {\n        force: false\n      });\n    }\n    // The spec indicates that if the operation times out or fails with a non-retryable error, we should ignore all errors on `abortTransaction`\n    return;\n  }\n  session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n  if (error instanceof error_1.MongoError) {\n    if ((0, error_1.isRetryableWriteError)(error) || error instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(error)) {\n      if (isUnknownTransactionCommitResult(error)) {\n        error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n        // per txns spec, must unpin session in this case\n        session.unpin({\n          error\n        });\n      }\n    } else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n      session.unpin({\n        error\n      });\n    }\n  }\n  throw error;\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nclass ServerSession {\n  /** @internal */\n  constructor() {\n    this.id = {\n      id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = (0, utils_1.now)();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n  /**\n   * @internal\n   * Cloning meant to keep a readable reference to the server session data\n   * after ClientSession has ended\n   */\n  static clone(serverSession) {\n    const arrayBuffer = new ArrayBuffer(16);\n    const idBytes = Buffer.from(arrayBuffer);\n    idBytes.set(serverSession.id.id.buffer);\n    const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);\n    // Manual prototype construction to avoid modifying the constructor of this class\n    return Object.setPrototypeOf({\n      id: {\n        id\n      },\n      lastUse: serverSession.lastUse,\n      txnNumber: serverSession.txnNumber,\n      isDirty: serverSession.isDirty\n    }, ServerSession.prototype);\n  }\n}\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nclass ServerSessionPool {\n  constructor(client) {\n    if (client == null) {\n      throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');\n    }\n    this.client = client;\n    this.sessions = new utils_1.List();\n  }\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n  acquire() {\n    var _this$client$topology2, _this$client$topology3;\n    const sessionTimeoutMinutes = (_this$client$topology2 = (_this$client$topology3 = this.client.topology) === null || _this$client$topology3 === void 0 ? void 0 : _this$client$topology3.logicalSessionTimeoutMinutes) !== null && _this$client$topology2 !== void 0 ? _this$client$topology2 : 10;\n    let session = null;\n    // Try to obtain from session pool\n    while (this.sessions.length > 0) {\n      var _this$client$topology4;\n      const potentialSession = this.sessions.shift();\n      if (potentialSession != null && (!!((_this$client$topology4 = this.client.topology) !== null && _this$client$topology4 !== void 0 && _this$client$topology4.loadBalanced) || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {\n        session = potentialSession;\n        break;\n      }\n    }\n    // If nothing valid came from the pool make a new one\n    if (session == null) {\n      session = new ServerSession();\n    }\n    return session;\n  }\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n  release(session) {\n    var _this$client$topology5, _this$client$topology6, _this$client$topology7;\n    const sessionTimeoutMinutes = (_this$client$topology5 = (_this$client$topology6 = this.client.topology) === null || _this$client$topology6 === void 0 ? void 0 : _this$client$topology6.logicalSessionTimeoutMinutes) !== null && _this$client$topology5 !== void 0 ? _this$client$topology5 : 10;\n    if ((_this$client$topology7 = this.client.topology) !== null && _this$client$topology7 !== void 0 && _this$client$topology7.loadBalanced && !sessionTimeoutMinutes) {\n      this.sessions.unshift(session);\n    }\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n    this.sessions.prune(session => session.hasTimedOut(sessionTimeoutMinutes));\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      }\n      // otherwise, readd this session to the session pool\n      this.sessions.unshift(session);\n    }\n  }\n}\nexports.ServerSessionPool = ServerSessionPool;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\nfunction applySession(session, command, options) {\n  var _options$writeConcern2;\n  if (session.hasEnded) {\n    return new error_1.MongoExpiredSessionError();\n  }\n  // May acquire serverSession here\n  const serverSession = session.serverSession;\n  if (serverSession == null) {\n    return new error_1.MongoRuntimeError('Unable to acquire server session');\n  }\n  if (((_options$writeConcern2 = options.writeConcern) === null || _options$writeConcern2 === void 0 ? void 0 : _options$writeConcern2.w) === 0) {\n    if (session && session.explicit) {\n      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n      return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n    return;\n  }\n  // mark the last use of this session, and apply the `lsid`\n  serverSession.lastUse = (0, utils_1.now)();\n  command.lsid = serverSession.id;\n  const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);\n  const isRetryableWrite = !!options.willRetryWrite;\n  if (isRetryableWrite || inTxnOrTxnCommand) {\n    serverSession.txnNumber += session[kTxnNumberIncrement];\n    session[kTxnNumberIncrement] = 0;\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n  }\n  if (!inTxnOrTxnCommand) {\n    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n    }\n    if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command)) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || {\n        level: read_concern_1.ReadConcernLevel.snapshot\n      };\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, {\n          atClusterTime: session[kSnapshotTime]\n        });\n      }\n    }\n    return;\n  }\n  // now attempt to apply transaction-specific sessions data\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n    var _session$clientOption;\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    const readConcern = session.transaction.options.readConcern || (session === null || session === void 0 || (_session$clientOption = session.clientOptions) === null || _session$clientOption === void 0 ? void 0 : _session$clientOption.readConcern);\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n  return;\n}\nexports.applySession = applySession;\nfunction updateSessionFromResponse(session, document) {\n  if (document.$clusterTime) {\n    (0, common_1._advanceClusterTime)(session, document.$clusterTime);\n  }\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n  if (session !== null && session !== void 0 && session[kSnapshotEnabled] && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = document.atClusterTime;\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\nexports.updateSessionFromResponse = updateSessionFromResponse;","map":{"version":3,"names":["bson_1","require","metrics_1","shared_1","constants_1","error_1","mongo_types_1","execute_operation_1","run_command_1","read_concern_1","read_preference_1","common_1","transactions_1","utils_1","write_concern_1","minWireVersionForShardedTransactions","kServerSession","Symbol","kSnapshotTime","kSnapshotEnabled","kPinnedConnection","kTxnNumberIncrement","ClientSession","TypedEventEmitter","constructor","client","sessionPool","options","clientOptions","_options","_options$defaultTimeo","_client$options","_options$causalConsis","_a","MongoRuntimeError","ServerSessionPool","snapshot","causalConsistency","MongoInvalidArgumentError","hasEnded","timeoutMS","defaultTimeoutMS","explicit","acquire","defaultCausalConsistencyValue","supports","clusterTime","initialClusterTime","operationTime","undefined","owner","defaultTransactionOptions","transaction","Transaction","id","_this$kServerSession","serverSession","snapshotEnabled","loadBalanced","_this$client$topology","topology","description","type","TopologyType","LoadBalanced","pinnedConnection","pin","conn","TypeError","emit","PINNED","inTransaction","ConnectionPoolMetrics","TXN","CURSOR","unpin","maybeClearPinnedConnection","unpinServer","isPinned","endSession","abortTransaction","release","Object","defineProperty","value","ServerSession","clone","writable","error","squashError","force","advanceOperationTime","greaterThan","advanceClusterTime","_clusterTime$signatur","_clusterTime$signatur2","_bsontype","signature","hash","keyId","_advanceClusterTime","equals","session","ByteUtils","buffer","incrementTransactionNumber","isActive","startTransaction","_ref","_options$readConcern","_this$clientOptions","_ref2","_options$writeConcern","_this$clientOptions2","_ref3","_options$readPreferen","_this$clientOptions3","_options$maxCommitTim","MongoCompatibilityError","MongoTransactionError","isCommitted","topologyMaxWireVersion","maxWireVersion","isSharded","readConcern","writeConcern","readPreference","maxCommitTimeMS","transition","TxnState","STARTING_TRANSACTION","commitTransaction","endTransaction","toBSON","withTransaction","fn","startTime","now","attemptTransaction","exports","MAX_WITH_TRANSACTION_TIMEOUT","NON_DETERMINISTIC_WRITE_CONCERN_ERRORS","Set","hasNotTimedOut","max","calculateDurationInMs","isUnknownTransactionCommitResult","err","isNonDeterministicWriteConcernError","MongoServerError","codeName","has","isMaxTimeMSExpiredError","code","MONGODB_ERROR_CODES","UnsatisfiableWriteConcern","UnknownReplWriteConcern","MongoError","hasErrorLabel","MongoErrorLabel","TransientTransactionError","servers","Array","from","s","values","loadBalancer","pool","checkIn","UNPINNED","state","NO_TRANSACTION","forceClear","clear","serviceId","MaxTimeMSExpired","writeConcernError","attemptTransactionCommit","result","commitErr","UnknownTransactionCommitResult","USER_EXPLICIT_TXN_END_STATES","TRANSACTION_COMMITTED","TRANSACTION_ABORTED","userExplicitlyEndedTransaction","arguments","length","promise","Promise","reject","isPromiseLike","addErrorLabel","commandName","txnState","TRANSACTION_COMMITTED_EMPTY","command","assign","w","wtimeoutMS","WriteConcern","apply","maxTimeMS","recoveryToken","executeOperation","RunAdminCommandOperation","ReadPreference","primary","bypassPinningCheck","firstAttemptErr","isRetryableWriteError","wtimeout","secondAttemptErr","handleEndTransactionError","MongoWriteConcernError","Binary","uuidV4","SUBTYPE_UUID","lastUse","txnNumber","isDirty","hasTimedOut","sessionTimeoutMinutes","idleTimeMinutes","Math","round","arrayBuffer","ArrayBuffer","idBytes","Buffer","set","sub_type","setPrototypeOf","prototype","sessions","List","_this$client$topology2","_this$client$topology3","logicalSessionTimeoutMinutes","_this$client$topology4","potentialSession","shift","_this$client$topology5","_this$client$topology6","_this$client$topology7","unshift","prune","applySession","_options$writeConcern2","MongoExpiredSessionError","MongoAPIError","lsid","inTxnOrTxnCommand","isTransactionCommand","isRetryableWrite","willRetryWrite","Long","fromNumber","commandSupportsReadConcern","afterClusterTime","level","ReadConcernLevel","atClusterTime","autocommit","_session$clientOption","TRANSACTION_IN_PROGRESS","updateSessionFromResponse","document","$clusterTime","_recoveryToken"],"sources":["/Users/Regan/Documents/GitHub/BadBank/node_modules/mongodb/src/sessions.ts"],"sourcesContent":["import { Binary, type Document, Long, type Timestamp } from './bson';\nimport type { CommandOptions, Connection } from './cmap/connection';\nimport { ConnectionPoolMetrics } from './cmap/metrics';\nimport { type MongoDBResponse } from './cmap/wire_protocol/responses';\nimport { isSharded } from './cmap/wire_protocol/shared';\nimport { PINNED, UNPINNED } from './constants';\nimport type { AbstractCursor } from './cursor/abstract_cursor';\nimport {\n  type AnyError,\n  isRetryableWriteError,\n  MongoAPIError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  type MongoDriverError,\n  MongoError,\n  MongoErrorLabel,\n  MongoExpiredSessionError,\n  MongoInvalidArgumentError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError,\n  MongoWriteConcernError\n} from './error';\nimport type { MongoClient, MongoOptions } from './mongo_client';\nimport { TypedEventEmitter } from './mongo_types';\nimport { executeOperation } from './operations/execute_operation';\nimport { RunAdminCommandOperation } from './operations/run_command';\nimport { ReadConcernLevel } from './read_concern';\nimport { ReadPreference } from './read_preference';\nimport { _advanceClusterTime, type ClusterTime, TopologyType } from './sdam/common';\nimport {\n  isTransactionCommand,\n  Transaction,\n  type TransactionOptions,\n  TxnState\n} from './transactions';\nimport {\n  ByteUtils,\n  calculateDurationInMs,\n  commandSupportsReadConcern,\n  isPromiseLike,\n  List,\n  maxWireVersion,\n  now,\n  squashError,\n  uuidV4\n} from './utils';\nimport { WriteConcern } from './write_concern';\n\nconst minWireVersionForShardedTransactions = 8;\n\n/** @public */\nexport interface ClientSessionOptions {\n  /** Whether causal consistency should be enabled on this session */\n  causalConsistency?: boolean;\n  /** Whether all read operations should be read from the same snapshot for this session (NOTE: not compatible with `causalConsistency=true`) */\n  snapshot?: boolean;\n  /** The default TransactionOptions to use for transactions started on this session. */\n  defaultTransactionOptions?: TransactionOptions;\n  /** @internal\n   * The value of timeoutMS used for CSOT. Used to override client timeoutMS */\n  defaultTimeoutMS?: number;\n\n  /** @internal */\n  owner?: symbol | AbstractCursor;\n  /** @internal */\n  explicit?: boolean;\n  /** @internal */\n  initialClusterTime?: ClusterTime;\n}\n\n/** @public */\nexport type WithTransactionCallback<T = any> = (session: ClientSession) => Promise<T>;\n\n/** @public */\nexport type ClientSessionEvents = {\n  ended(session: ClientSession): void;\n};\n\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nconst kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\n\n/** @public */\nexport interface EndSessionOptions {\n  /**\n   * An optional error which caused the call to end this session\n   * @internal\n   */\n  error?: AnyError;\n  force?: boolean;\n  forceClear?: boolean;\n}\n\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nexport class ClientSession extends TypedEventEmitter<ClientSessionEvents> {\n  /** @internal */\n  client: MongoClient;\n  /** @internal */\n  sessionPool: ServerSessionPool;\n  hasEnded: boolean;\n  clientOptions?: MongoOptions;\n  supports: { causalConsistency: boolean };\n  clusterTime?: ClusterTime;\n  operationTime?: Timestamp;\n  explicit: boolean;\n  /** @internal */\n  owner?: symbol | AbstractCursor;\n  defaultTransactionOptions: TransactionOptions;\n  transaction: Transaction;\n  /** @internal */\n  [kServerSession]: ServerSession | null;\n  /** @internal */\n  [kSnapshotTime]?: Timestamp;\n  /** @internal */\n  [kSnapshotEnabled] = false;\n  /** @internal */\n  [kPinnedConnection]?: Connection;\n  /** @internal */\n  [kTxnNumberIncrement]: number;\n  /** @internal */\n  timeoutMS?: number;\n\n  /**\n   * Create a client session.\n   * @internal\n   * @param client - The current client\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(\n    client: MongoClient,\n    sessionPool: ServerSessionPool,\n    options: ClientSessionOptions,\n    clientOptions?: MongoOptions\n  ) {\n    super();\n\n    if (client == null) {\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError('ClientSession requires a MongoClient');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options ?? {};\n\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n      if (options.causalConsistency === true) {\n        throw new MongoInvalidArgumentError(\n          'Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive'\n        );\n      }\n    }\n\n    this.client = client;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this.timeoutMS = options.defaultTimeoutMS ?? client.options?.timeoutMS;\n\n    this.explicit = !!options.explicit;\n    this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\n    this[kTxnNumberIncrement] = 0;\n\n    const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;\n    this.supports = {\n      // if we can enable causal consistency, do so by default\n      causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue\n    };\n\n    this.clusterTime = options.initialClusterTime;\n\n    this.operationTime = undefined;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = { ...options.defaultTransactionOptions };\n    this.transaction = new Transaction();\n  }\n\n  /** The server id associated with this session */\n  get id(): ServerSessionId | undefined {\n    return this[kServerSession]?.id;\n  }\n\n  get serverSession(): ServerSession {\n    let serverSession = this[kServerSession];\n    if (serverSession == null) {\n      if (this.explicit) {\n        throw new MongoRuntimeError('Unexpected null serverSession for an explicit session');\n      }\n      if (this.hasEnded) {\n        throw new MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n      }\n      serverSession = this.sessionPool.acquire();\n      this[kServerSession] = serverSession;\n    }\n    return serverSession;\n  }\n\n  /** Whether or not this session is configured for snapshot reads */\n  get snapshotEnabled(): boolean {\n    return this[kSnapshotEnabled];\n  }\n\n  get loadBalanced(): boolean {\n    return this.client.topology?.description.type === TopologyType.LoadBalanced;\n  }\n\n  /** @internal */\n  get pinnedConnection(): Connection | undefined {\n    return this[kPinnedConnection];\n  }\n\n  /** @internal */\n  pin(conn: Connection): void {\n    if (this[kPinnedConnection]) {\n      throw TypeError('Cannot pin multiple connections to the same session');\n    }\n\n    this[kPinnedConnection] = conn;\n    conn.emit(\n      PINNED,\n      this.inTransaction() ? ConnectionPoolMetrics.TXN : ConnectionPoolMetrics.CURSOR\n    );\n  }\n\n  /** @internal */\n  unpin(options?: { force?: boolean; forceClear?: boolean; error?: AnyError }): void {\n    if (this.loadBalanced) {\n      return maybeClearPinnedConnection(this, options);\n    }\n\n    this.transaction.unpinServer();\n  }\n\n  get isPinned(): boolean {\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n  }\n\n  /**\n   * Ends this session on the server\n   *\n   * @param options - Optional settings. Currently reserved for future use\n   */\n  async endSession(options?: EndSessionOptions): Promise<void> {\n    try {\n      if (this.inTransaction()) {\n        await this.abortTransaction();\n      }\n      if (!this.hasEnded) {\n        const serverSession = this[kServerSession];\n        if (serverSession != null) {\n          // release the server session back to the pool\n          this.sessionPool.release(serverSession);\n          // Make sure a new serverSession never makes it onto this ClientSession\n          Object.defineProperty(this, kServerSession, {\n            value: ServerSession.clone(serverSession),\n            writable: false\n          });\n        }\n        // mark the session as ended, and emit a signal\n        this.hasEnded = true;\n        this.emit('ended', this);\n      }\n    } catch (error) {\n      // spec indicates that we should ignore all errors for `endSessions`\n      squashError(error);\n    } finally {\n      maybeClearPinnedConnection(this, { force: true, ...options });\n    }\n  }\n\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n  advanceOperationTime(operationTime: Timestamp): void {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n\n  /**\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n   *\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n   */\n  advanceClusterTime(clusterTime: ClusterTime): void {\n    if (!clusterTime || typeof clusterTime !== 'object') {\n      throw new MongoInvalidArgumentError('input cluster time must be an object');\n    }\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n      throw new MongoInvalidArgumentError(\n        'input cluster time \"clusterTime\" property must be a valid BSON Timestamp'\n      );\n    }\n    if (\n      !clusterTime.signature ||\n      clusterTime.signature.hash?._bsontype !== 'Binary' ||\n      (typeof clusterTime.signature.keyId !== 'bigint' &&\n        typeof clusterTime.signature.keyId !== 'number' &&\n        clusterTime.signature.keyId?._bsontype !== 'Long') // apparently we decode the key to number?\n    ) {\n      throw new MongoInvalidArgumentError(\n        'input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId'\n      );\n    }\n\n    _advanceClusterTime(this, clusterTime);\n  }\n\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n  equals(session: ClientSession): boolean {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n\n    return ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);\n  }\n\n  /**\n   * Increment the transaction number on the internal ServerSession\n   *\n   * @privateRemarks\n   * This helper increments a value stored on the client session that will be\n   * added to the serverSession's txnNumber upon applying it to a command.\n   * This is because the serverSession is lazily acquired after a connection is obtained\n   */\n  incrementTransactionNumber(): void {\n    this[kTxnNumberIncrement] += 1;\n  }\n\n  /** @returns whether this session is currently in a transaction or not */\n  inTransaction(): boolean {\n    return this.transaction.isActive;\n  }\n\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @remarks\n   * **IMPORTANT**: Running operations in parallel is not supported during a transaction. The use of `Promise.all`,\n   * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is\n   * undefined behaviour.\n   *\n   * @param options - Options for the transaction\n   */\n  startTransaction(options?: TransactionOptions): void {\n    if (this[kSnapshotEnabled]) {\n      throw new MongoCompatibilityError('Transactions are not supported in snapshot sessions');\n    }\n\n    if (this.inTransaction()) {\n      throw new MongoTransactionError('Transaction already in progress');\n    }\n\n    if (this.isPinned && this.transaction.isCommitted) {\n      this.unpin();\n    }\n\n    const topologyMaxWireVersion = maxWireVersion(this.client.topology);\n    if (\n      isSharded(this.client.topology) &&\n      topologyMaxWireVersion != null &&\n      topologyMaxWireVersion < minWireVersionForShardedTransactions\n    ) {\n      throw new MongoCompatibilityError(\n        'Transactions are not supported on sharded clusters in MongoDB < 4.2.'\n      );\n    }\n\n    // increment txnNumber\n    this.incrementTransactionNumber();\n    // create transaction state\n    this.transaction = new Transaction({\n      readConcern:\n        options?.readConcern ??\n        this.defaultTransactionOptions.readConcern ??\n        this.clientOptions?.readConcern,\n      writeConcern:\n        options?.writeConcern ??\n        this.defaultTransactionOptions.writeConcern ??\n        this.clientOptions?.writeConcern,\n      readPreference:\n        options?.readPreference ??\n        this.defaultTransactionOptions.readPreference ??\n        this.clientOptions?.readPreference,\n      maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS\n    });\n\n    this.transaction.transition(TxnState.STARTING_TRANSACTION);\n  }\n\n  /**\n   * Commits the currently active transaction in this session.\n   */\n  async commitTransaction(): Promise<void> {\n    return await endTransaction(this, 'commitTransaction');\n  }\n\n  /**\n   * Aborts the currently active transaction in this session.\n   */\n  async abortTransaction(): Promise<void> {\n    return await endTransaction(this, 'abortTransaction');\n  }\n\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n  toBSON(): never {\n    throw new MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n  }\n\n  /**\n   * Starts a transaction and runs a provided function, ensuring the commitTransaction is always attempted when all operations run in the function have completed.\n   *\n   * **IMPORTANT:** This method requires the function passed in to return a Promise. That promise must be made by `await`-ing all operations in such a way that rejections are propagated to the returned promise.\n   *\n   * **IMPORTANT:** Running operations in parallel is not supported during a transaction. The use of `Promise.all`,\n   * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is\n   * undefined behaviour.\n   *\n   *\n   * @remarks\n   * - If all operations successfully complete and the `commitTransaction` operation is successful, then the provided function will return the result of the provided function.\n   * - If the transaction is unable to complete or an error is thrown from within the provided function, then the provided function will throw an error.\n   *   - If the transaction is manually aborted within the provided function it will not throw.\n   * - If the driver needs to attempt to retry the operations, the provided function may be called multiple times.\n   *\n   * Checkout a descriptive example here:\n   * @see https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions\n   *\n   * If a command inside withTransaction fails:\n   * - It may cause the transaction on the server to be aborted.\n   * - This situation is normally handled transparently by the driver.\n   * - However, if the application catches such an error and does not rethrow it, the driver will not be able to determine whether the transaction was aborted or not.\n   * - The driver will then retry the transaction indefinitely.\n   *\n   * To avoid this situation, the application must not silently handle errors within the provided function.\n   * If the application needs to handle errors within, it must await all operations such that if an operation is rejected it becomes the rejection of the callback function passed into withTransaction.\n   *\n   * @param fn - callback to run within a transaction\n   * @param options - optional settings for the transaction\n   * @returns A raw command response or undefined\n   */\n  async withTransaction<T = any>(\n    fn: WithTransactionCallback<T>,\n    options?: TransactionOptions\n  ): Promise<T> {\n    const startTime = now();\n    return await attemptTransaction(this, startTime, fn, options);\n  }\n}\n\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([\n  'CannotSatisfyWriteConcern',\n  'UnknownReplWriteConcern',\n  'UnsatisfiableWriteConcern'\n]);\n\nfunction hasNotTimedOut(startTime: number, max: number) {\n  return calculateDurationInMs(startTime) < max;\n}\n\nfunction isUnknownTransactionCommitResult(err: MongoError) {\n  const isNonDeterministicWriteConcernError =\n    err instanceof MongoServerError &&\n    err.codeName &&\n    NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n\n  return (\n    isMaxTimeMSExpiredError(err) ||\n    (!isNonDeterministicWriteConcernError &&\n      err.code !== MONGODB_ERROR_CODES.UnsatisfiableWriteConcern &&\n      err.code !== MONGODB_ERROR_CODES.UnknownReplWriteConcern)\n  );\n}\n\nexport function maybeClearPinnedConnection(\n  session: ClientSession,\n  options?: EndSessionOptions\n): void {\n  // unpin a connection if it has been pinned\n  const conn = session[kPinnedConnection];\n  const error = options?.error;\n\n  if (\n    session.inTransaction() &&\n    error &&\n    error instanceof MongoError &&\n    error.hasErrorLabel(MongoErrorLabel.TransientTransactionError)\n  ) {\n    return;\n  }\n\n  const topology = session.client.topology;\n  // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n  if (conn && topology != null) {\n    const servers = Array.from(topology.s.servers.values());\n    const loadBalancer = servers[0];\n\n    if (options?.error == null || options?.force) {\n      loadBalancer.pool.checkIn(conn);\n      session[kPinnedConnection] = undefined;\n      conn.emit(\n        UNPINNED,\n        session.transaction.state !== TxnState.NO_TRANSACTION\n          ? ConnectionPoolMetrics.TXN\n          : ConnectionPoolMetrics.CURSOR\n      );\n\n      if (options?.forceClear) {\n        loadBalancer.pool.clear({ serviceId: conn.serviceId });\n      }\n    }\n  }\n}\n\nfunction isMaxTimeMSExpiredError(err: MongoError) {\n  if (err == null || !(err instanceof MongoServerError)) {\n    return false;\n  }\n\n  return (\n    err.code === MONGODB_ERROR_CODES.MaxTimeMSExpired ||\n    (err.writeConcernError && err.writeConcernError.code === MONGODB_ERROR_CODES.MaxTimeMSExpired)\n  );\n}\n\nasync function attemptTransactionCommit<T>(\n  session: ClientSession,\n  startTime: number,\n  fn: WithTransactionCallback<T>,\n  result: T,\n  options: TransactionOptions\n): Promise<T> {\n  try {\n    await session.commitTransaction();\n    return result;\n  } catch (commitErr) {\n    if (\n      commitErr instanceof MongoError &&\n      hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) &&\n      !isMaxTimeMSExpiredError(commitErr)\n    ) {\n      if (commitErr.hasErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult)) {\n        return await attemptTransactionCommit(session, startTime, fn, result, options);\n      }\n\n      if (commitErr.hasErrorLabel(MongoErrorLabel.TransientTransactionError)) {\n        return await attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw commitErr;\n  }\n}\n\nconst USER_EXPLICIT_TXN_END_STATES = new Set<TxnState>([\n  TxnState.NO_TRANSACTION,\n  TxnState.TRANSACTION_COMMITTED,\n  TxnState.TRANSACTION_ABORTED\n]);\n\nfunction userExplicitlyEndedTransaction(session: ClientSession) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nasync function attemptTransaction<T>(\n  session: ClientSession,\n  startTime: number,\n  fn: WithTransactionCallback<T>,\n  options: TransactionOptions = {}\n): Promise<T> {\n  session.startTransaction(options);\n\n  let promise;\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n\n  if (!isPromiseLike(promise)) {\n    try {\n      await session.abortTransaction();\n    } catch (error) {\n      squashError(error);\n    }\n    throw new MongoInvalidArgumentError(\n      'Function provided to `withTransaction` must return a Promise'\n    );\n  }\n\n  try {\n    const result = await promise;\n    if (userExplicitlyEndedTransaction(session)) {\n      return result;\n    }\n    return await attemptTransactionCommit(session, startTime, fn, result, options);\n  } catch (err) {\n    if (session.inTransaction()) {\n      await session.abortTransaction();\n    }\n\n    if (\n      err instanceof MongoError &&\n      err.hasErrorLabel(MongoErrorLabel.TransientTransactionError) &&\n      hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)\n    ) {\n      return await attemptTransaction(session, startTime, fn, options);\n    }\n\n    if (isMaxTimeMSExpiredError(err)) {\n      err.addErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult);\n    }\n\n    throw err;\n  }\n}\n\nasync function endTransaction(\n  session: ClientSession,\n  commandName: 'abortTransaction' | 'commitTransaction'\n): Promise<void> {\n  // handle any initial problematic cases\n  const txnState = session.transaction.state;\n\n  if (txnState === TxnState.NO_TRANSACTION) {\n    throw new MongoTransactionError('No transaction started');\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (\n      txnState === TxnState.STARTING_TRANSACTION ||\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      throw new MongoTransactionError(\n        'Cannot call commitTransaction after calling abortTransaction'\n      );\n    }\n  } else {\n    if (txnState === TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      throw new MongoTransactionError('Cannot call abortTransaction twice');\n    }\n\n    if (\n      txnState === TxnState.TRANSACTION_COMMITTED ||\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      throw new MongoTransactionError(\n        'Cannot call abortTransaction after calling commitTransaction'\n      );\n    }\n  }\n\n  // construct and send the command\n  const command: Document = { [commandName]: 1 };\n\n  // apply a writeConcern if specified\n  let writeConcern;\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = { w: session.clientOptions.writeConcern.w };\n  }\n\n  if (txnState === TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({ wtimeoutMS: 10000 }, writeConcern, { w: 'majority' });\n  }\n\n  if (writeConcern) {\n    WriteConcern.apply(command, writeConcern);\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });\n  }\n\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  }\n\n  try {\n    // send the command\n    await executeOperation(\n      session.client,\n      new RunAdminCommandOperation(command, {\n        session,\n        readPreference: ReadPreference.primary,\n        bypassPinningCheck: true\n      })\n    );\n    if (command.abortTransaction) {\n      // always unpin on abort regardless of command outcome\n      session.unpin();\n    }\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, { force: false });\n      }\n    } else {\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\n    }\n  } catch (firstAttemptErr) {\n    if (command.abortTransaction) {\n      // always unpin on abort regardless of command outcome\n      session.unpin();\n    }\n    if (firstAttemptErr instanceof MongoError && isRetryableWriteError(firstAttemptErr)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.unpin({ force: true });\n\n        command.writeConcern = Object.assign({ wtimeout: 10000 }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n\n      try {\n        await executeOperation(\n          session.client,\n          new RunAdminCommandOperation(command, {\n            session,\n            readPreference: ReadPreference.primary,\n            bypassPinningCheck: true\n          })\n        );\n        if (commandName !== 'commitTransaction') {\n          session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n          if (session.loadBalanced) {\n            maybeClearPinnedConnection(session, { force: false });\n          }\n        } else {\n          session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\n        }\n      } catch (secondAttemptErr) {\n        handleEndTransactionError(session, commandName, secondAttemptErr);\n      }\n    } else {\n      handleEndTransactionError(session, commandName, firstAttemptErr);\n    }\n  }\n}\n\nfunction handleEndTransactionError(\n  session: ClientSession,\n  commandName: 'abortTransaction' | 'commitTransaction',\n  error: Error\n) {\n  if (commandName !== 'commitTransaction') {\n    session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n    if (session.loadBalanced) {\n      maybeClearPinnedConnection(session, { force: false });\n    }\n    // The spec indicates that if the operation times out or fails with a non-retryable error, we should ignore all errors on `abortTransaction`\n    return;\n  }\n\n  session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\n  if (error instanceof MongoError) {\n    if (\n      isRetryableWriteError(error) ||\n      error instanceof MongoWriteConcernError ||\n      isMaxTimeMSExpiredError(error)\n    ) {\n      if (isUnknownTransactionCommitResult(error)) {\n        error.addErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult);\n\n        // per txns spec, must unpin session in this case\n        session.unpin({ error });\n      }\n    } else if (error.hasErrorLabel(MongoErrorLabel.TransientTransactionError)) {\n      session.unpin({ error });\n    }\n  }\n\n  throw error;\n}\n\n/** @public */\nexport type ServerSessionId = { id: Binary };\n\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nexport class ServerSession {\n  id: ServerSessionId;\n  lastUse: number;\n  txnNumber: number;\n  isDirty: boolean;\n\n  /** @internal */\n  constructor() {\n    this.id = { id: new Binary(uuidV4(), Binary.SUBTYPE_UUID) };\n    this.lastUse = now();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n  hasTimedOut(sessionTimeoutMinutes: number): boolean {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round(\n      ((calculateDurationInMs(this.lastUse) % 86400000) % 3600000) / 60000\n    );\n\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n\n  /**\n   * @internal\n   * Cloning meant to keep a readable reference to the server session data\n   * after ClientSession has ended\n   */\n  static clone(serverSession: ServerSession): Readonly<ServerSession> {\n    const arrayBuffer = new ArrayBuffer(16);\n    const idBytes = Buffer.from(arrayBuffer);\n    idBytes.set(serverSession.id.id.buffer);\n\n    const id = new Binary(idBytes, serverSession.id.id.sub_type);\n\n    // Manual prototype construction to avoid modifying the constructor of this class\n    return Object.setPrototypeOf(\n      {\n        id: { id },\n        lastUse: serverSession.lastUse,\n        txnNumber: serverSession.txnNumber,\n        isDirty: serverSession.isDirty\n      },\n      ServerSession.prototype\n    );\n  }\n}\n\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nexport class ServerSessionPool {\n  client: MongoClient;\n  sessions: List<ServerSession>;\n\n  constructor(client: MongoClient) {\n    if (client == null) {\n      throw new MongoRuntimeError('ServerSessionPool requires a MongoClient');\n    }\n\n    this.client = client;\n    this.sessions = new List<ServerSession>();\n  }\n\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n  acquire(): ServerSession {\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n\n    let session: ServerSession | null = null;\n\n    // Try to obtain from session pool\n    while (this.sessions.length > 0) {\n      const potentialSession = this.sessions.shift();\n      if (\n        potentialSession != null &&\n        (!!this.client.topology?.loadBalanced ||\n          !potentialSession.hasTimedOut(sessionTimeoutMinutes))\n      ) {\n        session = potentialSession;\n        break;\n      }\n    }\n\n    // If nothing valid came from the pool make a new one\n    if (session == null) {\n      session = new ServerSession();\n    }\n\n    return session;\n  }\n\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n  release(session: ServerSession): void {\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n\n    if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {\n      this.sessions.unshift(session);\n    }\n\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n\n    this.sessions.prune(session => session.hasTimedOut(sessionTimeoutMinutes));\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      }\n\n      // otherwise, readd this session to the session pool\n      this.sessions.unshift(session);\n    }\n  }\n}\n\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\nexport function applySession(\n  session: ClientSession,\n  command: Document,\n  options: CommandOptions\n): MongoDriverError | undefined {\n  if (session.hasEnded) {\n    return new MongoExpiredSessionError();\n  }\n\n  // May acquire serverSession here\n  const serverSession = session.serverSession;\n  if (serverSession == null) {\n    return new MongoRuntimeError('Unable to acquire server session');\n  }\n\n  if (options.writeConcern?.w === 0) {\n    if (session && session.explicit) {\n      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n      return new MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n    return;\n  }\n\n  // mark the last use of this session, and apply the `lsid`\n  serverSession.lastUse = now();\n  command.lsid = serverSession.id;\n\n  const inTxnOrTxnCommand = session.inTransaction() || isTransactionCommand(command);\n  const isRetryableWrite = !!options.willRetryWrite;\n\n  if (isRetryableWrite || inTxnOrTxnCommand) {\n    serverSession.txnNumber += session[kTxnNumberIncrement];\n    session[kTxnNumberIncrement] = 0;\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    command.txnNumber = Long.fromNumber(serverSession.txnNumber);\n  }\n\n  if (!inTxnOrTxnCommand) {\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\n      session.transaction.transition(TxnState.NO_TRANSACTION);\n    }\n\n    if (\n      session.supports.causalConsistency &&\n      session.operationTime &&\n      commandSupportsReadConcern(command)\n    ) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || { level: ReadConcernLevel.snapshot };\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });\n      }\n    }\n\n    return;\n  }\n\n  // now attempt to apply transaction-specific sessions data\n\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n\n    const readConcern =\n      session.transaction.options.readConcern || session?.clientOptions?.readConcern;\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    }\n  }\n  return;\n}\n\nexport function updateSessionFromResponse(session: ClientSession, document: MongoDBResponse): void {\n  if (document.$clusterTime) {\n    _advanceClusterTime(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n\n  if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = document.atClusterTime;\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}