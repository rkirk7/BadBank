{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RTTSampler = exports.MonitorInterval = exports.RTTPinger = exports.Monitor = exports.ServerMonitoringMode = void 0;\nconst timers_1 = require(\"timers\");\nconst bson_1 = require(\"../bson\");\nconst connect_1 = require(\"../cmap/connect\");\nconst client_metadata_1 = require(\"../cmap/handshake/client_metadata\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst mongo_logger_1 = require(\"../mongo_logger\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst utils_1 = require(\"../utils\");\nconst common_1 = require(\"./common\");\nconst events_1 = require(\"./events\");\nconst server_1 = require(\"./server\");\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kMonitorId = Symbol('monitorId');\n/** @internal */\nconst kCancellationToken = Symbol('cancellationToken');\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = (0, utils_1.makeStateMachine)({\n  [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],\n  [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);\nfunction isInCloseState(monitor) {\n  return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;\n}\n/** @public */\nexports.ServerMonitoringMode = Object.freeze({\n  auto: 'auto',\n  poll: 'poll',\n  stream: 'stream'\n});\n/** @internal */\nclass Monitor extends mongo_types_1.TypedEventEmitter {\n  constructor(server, options) {\n    var _options$connectTimeo, _options$heartbeatFre, _options$minHeartbeat, _this$kServer$topolog;\n    super();\n    /** @internal */\n    this.component = mongo_logger_1.MongoLoggableComponent.TOPOLOGY;\n    this[kServer] = server;\n    this.connection = null;\n    this[kCancellationToken] = new mongo_types_1.CancellationToken();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = undefined;\n    this.s = {\n      state: common_1.STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: (_options$connectTimeo = options.connectTimeoutMS) !== null && _options$connectTimeo !== void 0 ? _options$connectTimeo : 10000,\n      heartbeatFrequencyMS: (_options$heartbeatFre = options.heartbeatFrequencyMS) !== null && _options$heartbeatFre !== void 0 ? _options$heartbeatFre : 10000,\n      minHeartbeatFrequencyMS: (_options$minHeartbeat = options.minHeartbeatFrequencyMS) !== null && _options$minHeartbeat !== void 0 ? _options$minHeartbeat : 500,\n      serverMonitoringMode: options.serverMonitoringMode\n    });\n    this.isRunningInFaasEnv = (0, client_metadata_1.getFAASEnv)() != null;\n    this.mongoLogger = (_this$kServer$topolog = this[kServer].topology.client) === null || _this$kServer$topolog === void 0 ? void 0 : _this$kServer$topolog.mongoLogger;\n    this.rttSampler = new RTTSampler(10);\n    const cancellationToken = this[kCancellationToken];\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n    const connectOptions = {\n      id: '<monitor>',\n      generation: server.pool.generation,\n      cancellationToken,\n      hostAddress: server.description.hostAddress,\n      ...options,\n      // force BSON serialization options\n      raw: false,\n      useBigInt64: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    };\n    // ensure no authentication is used for monitoring\n    delete connectOptions.credentials;\n    if (connectOptions.autoEncrypter) {\n      delete connectOptions.autoEncrypter;\n    }\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n  connect() {\n    if (this.s.state !== common_1.STATE_CLOSED) {\n      return;\n    }\n    // start\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n  requestCheck() {\n    var _this$kMonitorId;\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n    (_this$kMonitorId = this[kMonitorId]) === null || _this$kMonitorId === void 0 || _this$kMonitorId.wake();\n  }\n  reset() {\n    const topologyVersion = this[kServer].description.topologyVersion;\n    if (isInCloseState(this) || topologyVersion == null) {\n      return;\n    }\n    stateTransition(this, common_1.STATE_CLOSING);\n    resetMonitorState(this);\n    // restart monitor\n    stateTransition(this, STATE_IDLE);\n    // restart monitoring\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS\n    });\n  }\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n    stateTransition(this, common_1.STATE_CLOSING);\n    resetMonitorState(this);\n    // close monitor\n    this.emit('close');\n    stateTransition(this, common_1.STATE_CLOSED);\n  }\n  get roundTripTime() {\n    return this.rttSampler.average();\n  }\n  get minRoundTripTime() {\n    return this.rttSampler.min();\n  }\n  get latestRtt() {\n    return this.rttSampler.last;\n  }\n  addRttSample(rtt) {\n    this.rttSampler.addSample(rtt);\n  }\n  clearRttSamples() {\n    this.rttSampler.clear();\n  }\n}\nexports.Monitor = Monitor;\nfunction resetMonitorState(monitor) {\n  var _monitor$kMonitorId, _monitor$rttPinger, _monitor$connection;\n  (_monitor$kMonitorId = monitor[kMonitorId]) === null || _monitor$kMonitorId === void 0 || _monitor$kMonitorId.stop();\n  monitor[kMonitorId] = undefined;\n  (_monitor$rttPinger = monitor.rttPinger) === null || _monitor$rttPinger === void 0 || _monitor$rttPinger.close();\n  monitor.rttPinger = undefined;\n  monitor[kCancellationToken].emit('cancel');\n  (_monitor$connection = monitor.connection) === null || _monitor$connection === void 0 || _monitor$connection.destroy();\n  monitor.connection = null;\n  monitor.clearRttSamples();\n}\nfunction useStreamingProtocol(monitor, topologyVersion) {\n  // If we have no topology version we always poll no matter\n  // what the user provided, since the server does not support\n  // the streaming protocol.\n  if (topologyVersion == null) return false;\n  const serverMonitoringMode = monitor.options.serverMonitoringMode;\n  if (serverMonitoringMode === exports.ServerMonitoringMode.poll) return false;\n  if (serverMonitoringMode === exports.ServerMonitoringMode.stream) return true;\n  // If we are in auto mode, we need to figure out if we're in a FaaS\n  // environment or not and choose the appropriate mode.\n  if (monitor.isRunningInFaasEnv) return false;\n  return true;\n}\nfunction checkServer(monitor, callback) {\n  let start;\n  let awaited;\n  const topologyVersion = monitor[kServer].description.topologyVersion;\n  const isAwaitable = useStreamingProtocol(monitor, topologyVersion);\n  monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor[kServer].topology.s.id, undefined, new events_1.ServerHeartbeatStartedEvent(monitor.address, isAwaitable));\n  function onHeartbeatFailed(err) {\n    var _monitor$connection2;\n    (_monitor$connection2 = monitor.connection) === null || _monitor$connection2 === void 0 || _monitor$connection2.destroy();\n    monitor.connection = null;\n    monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_FAILED, monitor[kServer].topology.s.id, undefined, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err, awaited));\n    const error = !(err instanceof error_1.MongoError) ? new error_1.MongoError(error_1.MongoError.buildErrorMessage(err), {\n      cause: err\n    }) : err;\n    error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);\n    if (error instanceof error_1.MongoNetworkTimeoutError) {\n      error.addErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);\n    }\n    monitor.emit('resetServer', error);\n    callback(err);\n  }\n  function onHeartbeatSucceeded(hello) {\n    var _monitor$rttPinger$la;\n    if (!('isWritablePrimary' in hello)) {\n      // Provide hello-style response document.\n      hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];\n    }\n    // NOTE: here we use the latestRtt as this measurement corresponds with the value\n    // obtained for this successful heartbeat, if there is no latestRtt, then we calculate the\n    // duration\n    const duration = isAwaitable && monitor.rttPinger ? (_monitor$rttPinger$la = monitor.rttPinger.latestRtt) !== null && _monitor$rttPinger$la !== void 0 ? _monitor$rttPinger$la : (0, utils_1.calculateDurationInMs)(start) : (0, utils_1.calculateDurationInMs)(start);\n    monitor.addRttSample(duration);\n    monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor[kServer].topology.s.id, hello.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello, isAwaitable));\n    if (isAwaitable) {\n      // If we are using the streaming protocol then we immediately issue another 'started'\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n      monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor[kServer].topology.s.id, undefined, new events_1.ServerHeartbeatStartedEvent(monitor.address, true));\n      // We have not actually sent an outgoing handshake, but when we get the next response we\n      // want the duration to reflect the time since we last heard from the server\n      start = (0, utils_1.now)();\n    } else {\n      var _monitor$rttPinger2;\n      (_monitor$rttPinger2 = monitor.rttPinger) === null || _monitor$rttPinger2 === void 0 || _monitor$rttPinger2.close();\n      monitor.rttPinger = undefined;\n      callback(undefined, hello);\n    }\n  }\n  const {\n    connection\n  } = monitor;\n  if (connection && !connection.closed) {\n    const {\n      serverApi,\n      helloOk\n    } = connection;\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const cmd = {\n      [serverApi !== null && serverApi !== void 0 && serverApi.version || helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: 1,\n      ...(isAwaitable && topologyVersion ? {\n        maxAwaitTimeMS,\n        topologyVersion: makeTopologyVersion(topologyVersion)\n      } : {})\n    };\n    const options = isAwaitable ? {\n      socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\n      exhaustAllowed: true\n    } : {\n      socketTimeoutMS: connectTimeoutMS\n    };\n    if (isAwaitable && monitor.rttPinger == null) {\n      monitor.rttPinger = new RTTPinger(monitor);\n    }\n    // Record new start time before sending handshake\n    start = (0, utils_1.now)();\n    if (isAwaitable) {\n      awaited = true;\n      return connection.exhaustCommand((0, utils_1.ns)('admin.$cmd'), cmd, options, (error, hello) => {\n        if (error) return onHeartbeatFailed(error);\n        return onHeartbeatSucceeded(hello);\n      });\n    }\n    awaited = false;\n    connection.command((0, utils_1.ns)('admin.$cmd'), cmd, options)\n    // eslint-disable-next-line github/no-then\n    .then(onHeartbeatSucceeded, onHeartbeatFailed);\n    return;\n  }\n  // connecting does an implicit `hello`\n  (async () => {\n    const socket = await (0, connect_1.makeSocket)(monitor.connectOptions);\n    const connection = (0, connect_1.makeConnection)(monitor.connectOptions, socket);\n    // The start time is after socket creation but before the handshake\n    start = (0, utils_1.now)();\n    try {\n      await (0, connect_1.performInitialHandshake)(connection, monitor.connectOptions);\n      return connection;\n    } catch (error) {\n      connection.destroy();\n      throw error;\n    }\n    // eslint-disable-next-line github/no-then\n  })().then(connection => {\n    var _connection$hello, _connection$hello2;\n    if (isInCloseState(monitor)) {\n      connection.destroy();\n      return;\n    }\n    const duration = (0, utils_1.calculateDurationInMs)(start);\n    monitor.addRttSample(duration);\n    monitor.connection = connection;\n    monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor[kServer].topology.s.id, (_connection$hello = connection.hello) === null || _connection$hello === void 0 ? void 0 : _connection$hello.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, connection.hello, useStreamingProtocol(monitor, (_connection$hello2 = connection.hello) === null || _connection$hello2 === void 0 ? void 0 : _connection$hello2.topologyVersion)));\n    callback(undefined, connection.hello);\n  }, error => {\n    monitor.connection = null;\n    awaited = false;\n    onHeartbeatFailed(error);\n  });\n}\nfunction monitorServer(monitor) {\n  return callback => {\n    if (monitor.s.state === STATE_MONITORING) {\n      process.nextTick(callback);\n      return;\n    }\n    stateTransition(monitor, STATE_MONITORING);\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n      callback();\n    }\n    checkServer(monitor, (err, hello) => {\n      if (err) {\n        // otherwise an error occurred on initial discovery, also bail\n        if (monitor[kServer].description.type === common_1.ServerType.Unknown) {\n          return done();\n        }\n      }\n      // if the check indicates streaming is supported, immediately reschedule monitoring\n      if (useStreamingProtocol(monitor, hello === null || hello === void 0 ? void 0 : hello.topologyVersion)) {\n        (0, timers_1.setTimeout)(() => {\n          if (!isInCloseState(monitor)) {\n            var _monitor$kMonitorId2;\n            (_monitor$kMonitorId2 = monitor[kMonitorId]) === null || _monitor$kMonitorId2 === void 0 || _monitor$kMonitorId2.wake();\n          }\n        }, 0);\n      }\n      done();\n    });\n  };\n}\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    // tests mock counter as just number, but in a real situation counter should always be a Long\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)\n  };\n}\n/** @internal */\nclass RTTPinger {\n  constructor(monitor) {\n    var _monitor$latestRtt;\n    this.connection = undefined;\n    this[kCancellationToken] = monitor[kCancellationToken];\n    this.closed = false;\n    this.monitor = monitor;\n    this.latestRtt = (_monitor$latestRtt = monitor.latestRtt) !== null && _monitor$latestRtt !== void 0 ? _monitor$latestRtt : undefined;\n    const heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;\n    this[kMonitorId] = (0, timers_1.setTimeout)(() => this.measureRoundTripTime(), heartbeatFrequencyMS);\n  }\n  get roundTripTime() {\n    return this.monitor.roundTripTime;\n  }\n  get minRoundTripTime() {\n    return this.monitor.minRoundTripTime;\n  }\n  close() {\n    var _this$connection;\n    this.closed = true;\n    (0, timers_1.clearTimeout)(this[kMonitorId]);\n    (_this$connection = this.connection) === null || _this$connection === void 0 || _this$connection.destroy();\n    this.connection = undefined;\n  }\n  measureAndReschedule(start, conn) {\n    if (this.closed) {\n      conn === null || conn === void 0 || conn.destroy();\n      return;\n    }\n    if (this.connection == null) {\n      this.connection = conn;\n    }\n    this.latestRtt = (0, utils_1.calculateDurationInMs)(start);\n    this[kMonitorId] = (0, timers_1.setTimeout)(() => this.measureRoundTripTime(), this.monitor.options.heartbeatFrequencyMS);\n  }\n  measureRoundTripTime() {\n    var _connection$serverApi;\n    const start = (0, utils_1.now)();\n    if (this.closed) {\n      return;\n    }\n    const connection = this.connection;\n    if (connection == null) {\n      // eslint-disable-next-line github/no-then\n      (0, connect_1.connect)(this.monitor.connectOptions).then(connection => {\n        this.measureAndReschedule(start, connection);\n      }, () => {\n        this.connection = undefined;\n      });\n      return;\n    }\n    const commandName = (_connection$serverApi = connection.serverApi) !== null && _connection$serverApi !== void 0 && _connection$serverApi.version || connection.helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND;\n    // eslint-disable-next-line github/no-then\n    connection.command((0, utils_1.ns)('admin.$cmd'), {\n      [commandName]: 1\n    }, undefined).then(() => this.measureAndReschedule(start), () => {\n      var _this$connection2;\n      (_this$connection2 = this.connection) === null || _this$connection2 === void 0 || _this$connection2.destroy();\n      this.connection = undefined;\n      return;\n    });\n  }\n}\nexports.RTTPinger = RTTPinger;\n/**\n * @internal\n */\nclass MonitorInterval {\n  constructor(fn) {\n    var _options$heartbeatFre2, _options$minHeartbeat2;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.isExpeditedCallToFnScheduled = false;\n    this.stopped = false;\n    this.isExecutionInProgress = false;\n    this.hasExecutedOnce = false;\n    this._executeAndReschedule = () => {\n      if (this.stopped) return;\n      if (this.timerId) {\n        (0, timers_1.clearTimeout)(this.timerId);\n      }\n      this.isExpeditedCallToFnScheduled = false;\n      this.isExecutionInProgress = true;\n      this.fn(() => {\n        this.lastExecutionEnded = (0, utils_1.now)();\n        this.isExecutionInProgress = false;\n        this._reschedule(this.heartbeatFrequencyMS);\n      });\n    };\n    this.fn = fn;\n    this.lastExecutionEnded = -Infinity;\n    this.heartbeatFrequencyMS = (_options$heartbeatFre2 = options.heartbeatFrequencyMS) !== null && _options$heartbeatFre2 !== void 0 ? _options$heartbeatFre2 : 1000;\n    this.minHeartbeatFrequencyMS = (_options$minHeartbeat2 = options.minHeartbeatFrequencyMS) !== null && _options$minHeartbeat2 !== void 0 ? _options$minHeartbeat2 : 500;\n    if (options.immediate) {\n      this._executeAndReschedule();\n    } else {\n      this._reschedule(undefined);\n    }\n  }\n  wake() {\n    const currentTime = (0, utils_1.now)();\n    const timeSinceLastCall = currentTime - this.lastExecutionEnded;\n    // TODO(NODE-4674): Add error handling and logging to the monitor\n    if (timeSinceLastCall < 0) {\n      return this._executeAndReschedule();\n    }\n    if (this.isExecutionInProgress) {\n      return;\n    }\n    // debounce multiple calls to wake within the `minInterval`\n    if (this.isExpeditedCallToFnScheduled) {\n      return;\n    }\n    // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n    if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {\n      this.isExpeditedCallToFnScheduled = true;\n      this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);\n      return;\n    }\n    this._executeAndReschedule();\n  }\n  stop() {\n    this.stopped = true;\n    if (this.timerId) {\n      (0, timers_1.clearTimeout)(this.timerId);\n      this.timerId = undefined;\n    }\n    this.lastExecutionEnded = -Infinity;\n    this.isExpeditedCallToFnScheduled = false;\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  toJSON() {\n    const currentTime = (0, utils_1.now)();\n    const timeSinceLastCall = currentTime - this.lastExecutionEnded;\n    return {\n      timerId: this.timerId != null ? 'set' : 'cleared',\n      lastCallTime: this.lastExecutionEnded,\n      isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,\n      stopped: this.stopped,\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,\n      currentTime,\n      timeSinceLastCall\n    };\n  }\n  _reschedule(ms) {\n    if (this.stopped) return;\n    if (this.timerId) {\n      (0, timers_1.clearTimeout)(this.timerId);\n    }\n    this.timerId = (0, timers_1.setTimeout)(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);\n  }\n}\nexports.MonitorInterval = MonitorInterval;\n/** @internal\n * This class implements the RTT sampling logic specified for [CSOT](https://github.com/mongodb/specifications/blob/bbb335e60cd7ea1e0f7cd9a9443cb95fc9d3b64d/source/client-side-operations-timeout/client-side-operations-timeout.md#drivers-use-minimum-rtt-to-short-circuit-operations)\n *\n * This is implemented as a [circular buffer](https://en.wikipedia.org/wiki/Circular_buffer) keeping\n * the most recent `windowSize` samples\n * */\nclass RTTSampler {\n  constructor() {\n    let windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    this.rttSamples = new Float64Array(windowSize);\n    this.length = 0;\n    this.writeIndex = 0;\n  }\n  /**\n   * Adds an rtt sample to the end of the circular buffer\n   * When `windowSize` samples have been collected, `addSample` overwrites the least recently added\n   * sample\n   */\n  addSample(sample) {\n    this.rttSamples[this.writeIndex++] = sample;\n    if (this.length < this.rttSamples.length) {\n      this.length++;\n    }\n    this.writeIndex %= this.rttSamples.length;\n  }\n  /**\n   * When \\< 2 samples have been collected, returns 0\n   * Otherwise computes the minimum value samples contained in the buffer\n   */\n  min() {\n    if (this.length < 2) return 0;\n    let min = this.rttSamples[0];\n    for (let i = 1; i < this.length; i++) {\n      if (this.rttSamples[i] < min) min = this.rttSamples[i];\n    }\n    return min;\n  }\n  /**\n   * Returns mean of samples contained in the buffer\n   */\n  average() {\n    if (this.length === 0) return 0;\n    let sum = 0;\n    for (let i = 0; i < this.length; i++) {\n      sum += this.rttSamples[i];\n    }\n    return sum / this.length;\n  }\n  /**\n   * Returns most recently inserted element in the buffer\n   * Returns null if the buffer is empty\n   * */\n  get last() {\n    if (this.length === 0) return null;\n    return this.rttSamples[this.writeIndex === 0 ? this.length - 1 : this.writeIndex - 1];\n  }\n  /**\n   * Clear the buffer\n   * NOTE: this does not overwrite the data held in the internal array, just the pointers into\n   * this array\n   */\n  clear() {\n    this.length = 0;\n    this.writeIndex = 0;\n  }\n}\nexports.RTTSampler = RTTSampler;","map":{"version":3,"names":["timers_1","require","bson_1","connect_1","client_metadata_1","constants_1","error_1","mongo_logger_1","mongo_types_1","utils_1","common_1","events_1","server_1","kServer","Symbol","kMonitorId","kCancellationToken","STATE_IDLE","STATE_MONITORING","stateTransition","makeStateMachine","STATE_CLOSING","STATE_CLOSED","INVALID_REQUEST_CHECK_STATES","Set","isInCloseState","monitor","s","state","exports","ServerMonitoringMode","Object","freeze","auto","poll","stream","Monitor","TypedEventEmitter","constructor","server","options","_options$connectTimeo","_options$heartbeatFre","_options$minHeartbeat","_this$kServer$topolog","component","MongoLoggableComponent","TOPOLOGY","connection","CancellationToken","setMaxListeners","Infinity","undefined","address","description","connectTimeoutMS","heartbeatFrequencyMS","minHeartbeatFrequencyMS","serverMonitoringMode","isRunningInFaasEnv","getFAASEnv","mongoLogger","topology","client","rttSampler","RTTSampler","cancellationToken","connectOptions","id","generation","pool","hostAddress","raw","useBigInt64","promoteLongs","promoteValues","promoteBuffers","credentials","autoEncrypter","connect","MonitorInterval","monitorServer","immediate","requestCheck","_this$kMonitorId","has","wake","reset","topologyVersion","resetMonitorState","close","emit","roundTripTime","average","minRoundTripTime","min","latestRtt","last","addRttSample","rtt","addSample","clearRttSamples","clear","_monitor$kMonitorId","_monitor$rttPinger","_monitor$connection","stop","rttPinger","destroy","useStreamingProtocol","checkServer","callback","start","awaited","isAwaitable","emitAndLogHeartbeat","Server","SERVER_HEARTBEAT_STARTED","ServerHeartbeatStartedEvent","onHeartbeatFailed","err","_monitor$connection2","SERVER_HEARTBEAT_FAILED","ServerHeartbeatFailedEvent","calculateDurationInMs","error","MongoError","buildErrorMessage","cause","addErrorLabel","MongoErrorLabel","ResetPool","MongoNetworkTimeoutError","InterruptInUseConnections","onHeartbeatSucceeded","hello","_monitor$rttPinger$la","isWritablePrimary","LEGACY_HELLO_COMMAND","duration","SERVER_HEARTBEAT_SUCCEEDED","connectionId","ServerHeartbeatSucceededEvent","now","_monitor$rttPinger2","closed","serverApi","helloOk","maxAwaitTimeMS","cmd","version","makeTopologyVersion","socketTimeoutMS","exhaustAllowed","RTTPinger","exhaustCommand","ns","command","then","socket","makeSocket","makeConnection","performInitialHandshake","_connection$hello","_connection$hello2","process","nextTick","done","type","ServerType","Unknown","setTimeout","_monitor$kMonitorId2","tv","processId","counter","Long","isLong","fromNumber","_monitor$latestRtt","measureRoundTripTime","_this$connection","clearTimeout","measureAndReschedule","conn","_connection$serverApi","commandName","_this$connection2","fn","_options$heartbeatFre2","_options$minHeartbeat2","arguments","length","isExpeditedCallToFnScheduled","stopped","isExecutionInProgress","hasExecutedOnce","_executeAndReschedule","timerId","lastExecutionEnded","_reschedule","currentTime","timeSinceLastCall","toString","JSON","stringify","toJSON","lastCallTime","isExpeditedCheckScheduled","ms","windowSize","rttSamples","Float64Array","writeIndex","sample","i","sum"],"sources":["/Users/Regan/Documents/GitHub/BadBank/node_modules/mongodb/src/sdam/monitor.ts"],"sourcesContent":["import { clearTimeout, setTimeout } from 'timers';\n\nimport { type Document, Long } from '../bson';\nimport { connect, makeConnection, makeSocket, performInitialHandshake } from '../cmap/connect';\nimport type { Connection, ConnectionOptions } from '../cmap/connection';\nimport { getFAASEnv } from '../cmap/handshake/client_metadata';\nimport { LEGACY_HELLO_COMMAND } from '../constants';\nimport { MongoError, MongoErrorLabel, MongoNetworkTimeoutError } from '../error';\nimport { MongoLoggableComponent } from '../mongo_logger';\nimport { CancellationToken, TypedEventEmitter } from '../mongo_types';\nimport {\n  calculateDurationInMs,\n  type Callback,\n  type EventEmitterWithState,\n  makeStateMachine,\n  now,\n  ns\n} from '../utils';\nimport { ServerType, STATE_CLOSED, STATE_CLOSING } from './common';\nimport {\n  ServerHeartbeatFailedEvent,\n  ServerHeartbeatStartedEvent,\n  ServerHeartbeatSucceededEvent\n} from './events';\nimport { Server } from './server';\nimport type { TopologyVersion } from './server_description';\n\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kMonitorId = Symbol('monitorId');\n/** @internal */\nconst kCancellationToken = Symbol('cancellationToken');\n\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\n\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\nfunction isInCloseState(monitor: Monitor) {\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\n}\n\n/** @public */\nexport const ServerMonitoringMode = Object.freeze({\n  auto: 'auto',\n  poll: 'poll',\n  stream: 'stream'\n} as const);\n\n/** @public */\nexport type ServerMonitoringMode = (typeof ServerMonitoringMode)[keyof typeof ServerMonitoringMode];\n\n/** @internal */\nexport interface MonitorPrivate {\n  state: string;\n}\n\n/** @public */\nexport interface MonitorOptions\n  extends Omit<ConnectionOptions, 'id' | 'generation' | 'hostAddress'> {\n  connectTimeoutMS: number;\n  heartbeatFrequencyMS: number;\n  minHeartbeatFrequencyMS: number;\n  serverMonitoringMode: ServerMonitoringMode;\n}\n\n/** @public */\nexport type MonitorEvents = {\n  serverHeartbeatStarted(event: ServerHeartbeatStartedEvent): void;\n  serverHeartbeatSucceeded(event: ServerHeartbeatSucceededEvent): void;\n  serverHeartbeatFailed(event: ServerHeartbeatFailedEvent): void;\n  resetServer(error?: MongoError): void;\n  resetConnectionPool(): void;\n  close(): void;\n} & EventEmitterWithState;\n\n/** @internal */\nexport class Monitor extends TypedEventEmitter<MonitorEvents> {\n  /** @internal */\n  s: MonitorPrivate;\n  address: string;\n  options: Readonly<\n    Pick<\n      MonitorOptions,\n      | 'connectTimeoutMS'\n      | 'heartbeatFrequencyMS'\n      | 'minHeartbeatFrequencyMS'\n      | 'serverMonitoringMode'\n    >\n  >;\n  connectOptions: ConnectionOptions;\n  isRunningInFaasEnv: boolean;\n  [kServer]: Server;\n  connection: Connection | null;\n  [kCancellationToken]: CancellationToken;\n  /** @internal */\n  [kMonitorId]?: MonitorInterval;\n  rttPinger?: RTTPinger;\n  /** @internal */\n  override component = MongoLoggableComponent.TOPOLOGY;\n  /** @internal */\n  private rttSampler: RTTSampler;\n\n  constructor(server: Server, options: MonitorOptions) {\n    super();\n\n    this[kServer] = server;\n    this.connection = null;\n    this[kCancellationToken] = new CancellationToken();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = undefined;\n    this.s = {\n      state: STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: options.connectTimeoutMS ?? 10000,\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 10000,\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500,\n      serverMonitoringMode: options.serverMonitoringMode\n    });\n    this.isRunningInFaasEnv = getFAASEnv() != null;\n    this.mongoLogger = this[kServer].topology.client?.mongoLogger;\n    this.rttSampler = new RTTSampler(10);\n\n    const cancellationToken = this[kCancellationToken];\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n    const connectOptions = {\n      id: '<monitor>' as const,\n      generation: server.pool.generation,\n      cancellationToken,\n      hostAddress: server.description.hostAddress,\n      ...options,\n      // force BSON serialization options\n      raw: false,\n      useBigInt64: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    };\n\n    // ensure no authentication is used for monitoring\n    delete connectOptions.credentials;\n    if (connectOptions.autoEncrypter) {\n      delete connectOptions.autoEncrypter;\n    }\n\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n\n  connect(): void {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    // start\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n\n  requestCheck(): void {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    this[kMonitorId]?.wake();\n  }\n\n  reset(): void {\n    const topologyVersion = this[kServer].description.topologyVersion;\n    if (isInCloseState(this) || topologyVersion == null) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // restart monitor\n    stateTransition(this, STATE_IDLE);\n\n    // restart monitoring\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS\n    });\n  }\n\n  close(): void {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // close monitor\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n\n  get roundTripTime(): number {\n    return this.rttSampler.average();\n  }\n\n  get minRoundTripTime(): number {\n    return this.rttSampler.min();\n  }\n\n  get latestRtt(): number | null {\n    return this.rttSampler.last;\n  }\n\n  addRttSample(rtt: number) {\n    this.rttSampler.addSample(rtt);\n  }\n\n  clearRttSamples() {\n    this.rttSampler.clear();\n  }\n}\n\nfunction resetMonitorState(monitor: Monitor) {\n  monitor[kMonitorId]?.stop();\n  monitor[kMonitorId] = undefined;\n\n  monitor.rttPinger?.close();\n  monitor.rttPinger = undefined;\n\n  monitor[kCancellationToken].emit('cancel');\n\n  monitor.connection?.destroy();\n  monitor.connection = null;\n\n  monitor.clearRttSamples();\n}\n\nfunction useStreamingProtocol(monitor: Monitor, topologyVersion: TopologyVersion | null): boolean {\n  // If we have no topology version we always poll no matter\n  // what the user provided, since the server does not support\n  // the streaming protocol.\n  if (topologyVersion == null) return false;\n\n  const serverMonitoringMode = monitor.options.serverMonitoringMode;\n  if (serverMonitoringMode === ServerMonitoringMode.poll) return false;\n  if (serverMonitoringMode === ServerMonitoringMode.stream) return true;\n\n  // If we are in auto mode, we need to figure out if we're in a FaaS\n  // environment or not and choose the appropriate mode.\n  if (monitor.isRunningInFaasEnv) return false;\n  return true;\n}\n\nfunction checkServer(monitor: Monitor, callback: Callback<Document | null>) {\n  let start: number;\n  let awaited: boolean;\n  const topologyVersion = monitor[kServer].description.topologyVersion;\n  const isAwaitable = useStreamingProtocol(monitor, topologyVersion);\n  monitor.emitAndLogHeartbeat(\n    Server.SERVER_HEARTBEAT_STARTED,\n    monitor[kServer].topology.s.id,\n    undefined,\n    new ServerHeartbeatStartedEvent(monitor.address, isAwaitable)\n  );\n\n  function onHeartbeatFailed(err: Error) {\n    monitor.connection?.destroy();\n    monitor.connection = null;\n    monitor.emitAndLogHeartbeat(\n      Server.SERVER_HEARTBEAT_FAILED,\n      monitor[kServer].topology.s.id,\n      undefined,\n      new ServerHeartbeatFailedEvent(monitor.address, calculateDurationInMs(start), err, awaited)\n    );\n\n    const error = !(err instanceof MongoError)\n      ? new MongoError(MongoError.buildErrorMessage(err), { cause: err })\n      : err;\n    error.addErrorLabel(MongoErrorLabel.ResetPool);\n    if (error instanceof MongoNetworkTimeoutError) {\n      error.addErrorLabel(MongoErrorLabel.InterruptInUseConnections);\n    }\n\n    monitor.emit('resetServer', error);\n    callback(err);\n  }\n\n  function onHeartbeatSucceeded(hello: Document) {\n    if (!('isWritablePrimary' in hello)) {\n      // Provide hello-style response document.\n      hello.isWritablePrimary = hello[LEGACY_HELLO_COMMAND];\n    }\n\n    // NOTE: here we use the latestRtt as this measurement corresponds with the value\n    // obtained for this successful heartbeat, if there is no latestRtt, then we calculate the\n    // duration\n    const duration =\n      isAwaitable && monitor.rttPinger\n        ? monitor.rttPinger.latestRtt ?? calculateDurationInMs(start)\n        : calculateDurationInMs(start);\n\n    monitor.addRttSample(duration);\n\n    monitor.emitAndLogHeartbeat(\n      Server.SERVER_HEARTBEAT_SUCCEEDED,\n      monitor[kServer].topology.s.id,\n      hello.connectionId,\n      new ServerHeartbeatSucceededEvent(monitor.address, duration, hello, isAwaitable)\n    );\n\n    if (isAwaitable) {\n      // If we are using the streaming protocol then we immediately issue another 'started'\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n      monitor.emitAndLogHeartbeat(\n        Server.SERVER_HEARTBEAT_STARTED,\n        monitor[kServer].topology.s.id,\n        undefined,\n        new ServerHeartbeatStartedEvent(monitor.address, true)\n      );\n      // We have not actually sent an outgoing handshake, but when we get the next response we\n      // want the duration to reflect the time since we last heard from the server\n      start = now();\n    } else {\n      monitor.rttPinger?.close();\n      monitor.rttPinger = undefined;\n\n      callback(undefined, hello);\n    }\n  }\n\n  const { connection } = monitor;\n  if (connection && !connection.closed) {\n    const { serverApi, helloOk } = connection;\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n\n    const cmd = {\n      [serverApi?.version || helloOk ? 'hello' : LEGACY_HELLO_COMMAND]: 1,\n      ...(isAwaitable && topologyVersion\n        ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) }\n        : {})\n    };\n\n    const options = isAwaitable\n      ? {\n          socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\n          exhaustAllowed: true\n        }\n      : { socketTimeoutMS: connectTimeoutMS };\n\n    if (isAwaitable && monitor.rttPinger == null) {\n      monitor.rttPinger = new RTTPinger(monitor);\n    }\n\n    // Record new start time before sending handshake\n    start = now();\n\n    if (isAwaitable) {\n      awaited = true;\n      return connection.exhaustCommand(ns('admin.$cmd'), cmd, options, (error, hello) => {\n        if (error) return onHeartbeatFailed(error);\n        return onHeartbeatSucceeded(hello);\n      });\n    }\n\n    awaited = false;\n    connection\n      .command(ns('admin.$cmd'), cmd, options)\n      // eslint-disable-next-line github/no-then\n      .then(onHeartbeatSucceeded, onHeartbeatFailed);\n\n    return;\n  }\n\n  // connecting does an implicit `hello`\n  (async () => {\n    const socket = await makeSocket(monitor.connectOptions);\n    const connection = makeConnection(monitor.connectOptions, socket);\n    // The start time is after socket creation but before the handshake\n    start = now();\n    try {\n      await performInitialHandshake(connection, monitor.connectOptions);\n      return connection;\n    } catch (error) {\n      connection.destroy();\n      throw error;\n    }\n    // eslint-disable-next-line github/no-then\n  })().then(\n    connection => {\n      if (isInCloseState(monitor)) {\n        connection.destroy();\n        return;\n      }\n      const duration = calculateDurationInMs(start);\n      monitor.addRttSample(duration);\n\n      monitor.connection = connection;\n      monitor.emitAndLogHeartbeat(\n        Server.SERVER_HEARTBEAT_SUCCEEDED,\n        monitor[kServer].topology.s.id,\n        connection.hello?.connectionId,\n        new ServerHeartbeatSucceededEvent(\n          monitor.address,\n          duration,\n          connection.hello,\n          useStreamingProtocol(monitor, connection.hello?.topologyVersion)\n        )\n      );\n\n      callback(undefined, connection.hello);\n    },\n    error => {\n      monitor.connection = null;\n      awaited = false;\n      onHeartbeatFailed(error);\n    }\n  );\n}\n\nfunction monitorServer(monitor: Monitor) {\n  return (callback: Callback) => {\n    if (monitor.s.state === STATE_MONITORING) {\n      process.nextTick(callback);\n      return;\n    }\n    stateTransition(monitor, STATE_MONITORING);\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    }\n\n    checkServer(monitor, (err, hello) => {\n      if (err) {\n        // otherwise an error occurred on initial discovery, also bail\n        if (monitor[kServer].description.type === ServerType.Unknown) {\n          return done();\n        }\n      }\n\n      // if the check indicates streaming is supported, immediately reschedule monitoring\n      if (useStreamingProtocol(monitor, hello?.topologyVersion)) {\n        setTimeout(() => {\n          if (!isInCloseState(monitor)) {\n            monitor[kMonitorId]?.wake();\n          }\n        }, 0);\n      }\n\n      done();\n    });\n  };\n}\n\nfunction makeTopologyVersion(tv: TopologyVersion) {\n  return {\n    processId: tv.processId,\n    // tests mock counter as just number, but in a real situation counter should always be a Long\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    counter: Long.isLong(tv.counter) ? tv.counter : Long.fromNumber(tv.counter)\n  };\n}\n\n/** @internal */\nexport interface RTTPingerOptions extends ConnectionOptions {\n  heartbeatFrequencyMS: number;\n}\n\n/** @internal */\nexport class RTTPinger {\n  connection?: Connection;\n  /** @internal */\n  [kCancellationToken]: CancellationToken;\n  /** @internal */\n  [kMonitorId]: NodeJS.Timeout;\n  /** @internal */\n  monitor: Monitor;\n  closed: boolean;\n  /** @internal */\n  latestRtt?: number;\n\n  constructor(monitor: Monitor) {\n    this.connection = undefined;\n    this[kCancellationToken] = monitor[kCancellationToken];\n    this.closed = false;\n    this.monitor = monitor;\n    this.latestRtt = monitor.latestRtt ?? undefined;\n\n    const heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;\n    this[kMonitorId] = setTimeout(() => this.measureRoundTripTime(), heartbeatFrequencyMS);\n  }\n\n  get roundTripTime(): number {\n    return this.monitor.roundTripTime;\n  }\n\n  get minRoundTripTime(): number {\n    return this.monitor.minRoundTripTime;\n  }\n\n  close(): void {\n    this.closed = true;\n    clearTimeout(this[kMonitorId]);\n\n    this.connection?.destroy();\n    this.connection = undefined;\n  }\n\n  private measureAndReschedule(start: number, conn?: Connection) {\n    if (this.closed) {\n      conn?.destroy();\n      return;\n    }\n\n    if (this.connection == null) {\n      this.connection = conn;\n    }\n\n    this.latestRtt = calculateDurationInMs(start);\n    this[kMonitorId] = setTimeout(\n      () => this.measureRoundTripTime(),\n      this.monitor.options.heartbeatFrequencyMS\n    );\n  }\n\n  private measureRoundTripTime() {\n    const start = now();\n\n    if (this.closed) {\n      return;\n    }\n\n    const connection = this.connection;\n    if (connection == null) {\n      // eslint-disable-next-line github/no-then\n      connect(this.monitor.connectOptions).then(\n        connection => {\n          this.measureAndReschedule(start, connection);\n        },\n        () => {\n          this.connection = undefined;\n        }\n      );\n      return;\n    }\n\n    const commandName =\n      connection.serverApi?.version || connection.helloOk ? 'hello' : LEGACY_HELLO_COMMAND;\n    // eslint-disable-next-line github/no-then\n    connection.command(ns('admin.$cmd'), { [commandName]: 1 }, undefined).then(\n      () => this.measureAndReschedule(start),\n      () => {\n        this.connection?.destroy();\n        this.connection = undefined;\n        return;\n      }\n    );\n  }\n}\n\n/**\n * @internal\n */\nexport interface MonitorIntervalOptions {\n  /** The interval to execute a method on */\n  heartbeatFrequencyMS: number;\n  /** A minimum interval that must elapse before the method is called */\n  minHeartbeatFrequencyMS: number;\n  /** Whether the method should be called immediately when the interval is started  */\n  immediate: boolean;\n}\n\n/**\n * @internal\n */\nexport class MonitorInterval {\n  fn: (callback: Callback) => void;\n  timerId: NodeJS.Timeout | undefined;\n  lastExecutionEnded: number;\n  isExpeditedCallToFnScheduled = false;\n  stopped = false;\n  isExecutionInProgress = false;\n  hasExecutedOnce = false;\n\n  heartbeatFrequencyMS: number;\n  minHeartbeatFrequencyMS: number;\n\n  constructor(fn: (callback: Callback) => void, options: Partial<MonitorIntervalOptions> = {}) {\n    this.fn = fn;\n    this.lastExecutionEnded = -Infinity;\n\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1000;\n    this.minHeartbeatFrequencyMS = options.minHeartbeatFrequencyMS ?? 500;\n\n    if (options.immediate) {\n      this._executeAndReschedule();\n    } else {\n      this._reschedule(undefined);\n    }\n  }\n\n  wake() {\n    const currentTime = now();\n    const timeSinceLastCall = currentTime - this.lastExecutionEnded;\n\n    // TODO(NODE-4674): Add error handling and logging to the monitor\n    if (timeSinceLastCall < 0) {\n      return this._executeAndReschedule();\n    }\n\n    if (this.isExecutionInProgress) {\n      return;\n    }\n\n    // debounce multiple calls to wake within the `minInterval`\n    if (this.isExpeditedCallToFnScheduled) {\n      return;\n    }\n\n    // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n    if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {\n      this.isExpeditedCallToFnScheduled = true;\n      this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);\n      return;\n    }\n\n    this._executeAndReschedule();\n  }\n\n  stop() {\n    this.stopped = true;\n    if (this.timerId) {\n      clearTimeout(this.timerId);\n      this.timerId = undefined;\n    }\n\n    this.lastExecutionEnded = -Infinity;\n    this.isExpeditedCallToFnScheduled = false;\n  }\n\n  toString() {\n    return JSON.stringify(this);\n  }\n\n  toJSON() {\n    const currentTime = now();\n    const timeSinceLastCall = currentTime - this.lastExecutionEnded;\n    return {\n      timerId: this.timerId != null ? 'set' : 'cleared',\n      lastCallTime: this.lastExecutionEnded,\n      isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,\n      stopped: this.stopped,\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,\n      currentTime,\n      timeSinceLastCall\n    };\n  }\n\n  private _reschedule(ms?: number) {\n    if (this.stopped) return;\n    if (this.timerId) {\n      clearTimeout(this.timerId);\n    }\n\n    this.timerId = setTimeout(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);\n  }\n\n  private _executeAndReschedule = () => {\n    if (this.stopped) return;\n    if (this.timerId) {\n      clearTimeout(this.timerId);\n    }\n\n    this.isExpeditedCallToFnScheduled = false;\n    this.isExecutionInProgress = true;\n\n    this.fn(() => {\n      this.lastExecutionEnded = now();\n      this.isExecutionInProgress = false;\n      this._reschedule(this.heartbeatFrequencyMS);\n    });\n  };\n}\n\n/** @internal\n * This class implements the RTT sampling logic specified for [CSOT](https://github.com/mongodb/specifications/blob/bbb335e60cd7ea1e0f7cd9a9443cb95fc9d3b64d/source/client-side-operations-timeout/client-side-operations-timeout.md#drivers-use-minimum-rtt-to-short-circuit-operations)\n *\n * This is implemented as a [circular buffer](https://en.wikipedia.org/wiki/Circular_buffer) keeping\n * the most recent `windowSize` samples\n * */\nexport class RTTSampler {\n  /** Index of the next slot to be overwritten */\n  private writeIndex: number;\n  private length: number;\n  private rttSamples: Float64Array;\n\n  constructor(windowSize = 10) {\n    this.rttSamples = new Float64Array(windowSize);\n    this.length = 0;\n    this.writeIndex = 0;\n  }\n\n  /**\n   * Adds an rtt sample to the end of the circular buffer\n   * When `windowSize` samples have been collected, `addSample` overwrites the least recently added\n   * sample\n   */\n  addSample(sample: number) {\n    this.rttSamples[this.writeIndex++] = sample;\n    if (this.length < this.rttSamples.length) {\n      this.length++;\n    }\n\n    this.writeIndex %= this.rttSamples.length;\n  }\n\n  /**\n   * When \\< 2 samples have been collected, returns 0\n   * Otherwise computes the minimum value samples contained in the buffer\n   */\n  min(): number {\n    if (this.length < 2) return 0;\n    let min = this.rttSamples[0];\n    for (let i = 1; i < this.length; i++) {\n      if (this.rttSamples[i] < min) min = this.rttSamples[i];\n    }\n\n    return min;\n  }\n\n  /**\n   * Returns mean of samples contained in the buffer\n   */\n  average(): number {\n    if (this.length === 0) return 0;\n    let sum = 0;\n    for (let i = 0; i < this.length; i++) {\n      sum += this.rttSamples[i];\n    }\n\n    return sum / this.length;\n  }\n\n  /**\n   * Returns most recently inserted element in the buffer\n   * Returns null if the buffer is empty\n   * */\n  get last(): number | null {\n    if (this.length === 0) return null;\n    return this.rttSamples[this.writeIndex === 0 ? this.length - 1 : this.writeIndex - 1];\n  }\n\n  /**\n   * Clear the buffer\n   * NOTE: this does not overwrite the data held in the internal array, just the pointers into\n   * this array\n   */\n  clear() {\n    this.length = 0;\n    this.writeIndex = 0;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}