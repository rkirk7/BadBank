{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CursorResponse = exports.MongoDBResponse = exports.isErrorResponse = void 0;\nconst bson_1 = require(\"../../bson\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\nconst document_1 = require(\"./on_demand/document\");\n/**\n * Accepts a BSON payload and checks for na \"ok: 0\" element.\n * This utility is intended to prevent calling response class constructors\n * that expect the result to be a success and demand certain properties to exist.\n *\n * For example, a cursor response always expects a cursor embedded document.\n * In order to write the class such that the properties reflect that assertion (non-null)\n * we cannot invoke the subclass constructor if the BSON represents an error.\n *\n * @param bytes - BSON document returned from the server\n */\nfunction isErrorResponse(bson) {\n  const elements = (0, bson_1.parseToElementsToArray)(bson, 0);\n  for (let eIdx = 0; eIdx < elements.length; eIdx++) {\n    const element = elements[eIdx];\n    if (element[2 /* BSONElementOffset.nameLength */] === 2) {\n      const nameOffset = element[1 /* BSONElementOffset.nameOffset */];\n      // 111 == \"o\", 107 == \"k\"\n      if (bson[nameOffset] === 111 && bson[nameOffset + 1] === 107) {\n        const valueOffset = element[3 /* BSONElementOffset.offset */];\n        const valueLength = element[4 /* BSONElementOffset.length */];\n        // If any byte in the length of the ok number (works for any type) is non zero,\n        // then it is considered \"ok: 1\"\n        for (let i = valueOffset; i < valueOffset + valueLength; i++) {\n          if (bson[i] !== 0x00) return false;\n        }\n        return true;\n      }\n    }\n  }\n  return true;\n}\nexports.isErrorResponse = isErrorResponse;\n/** @internal */\nclass MongoDBResponse extends document_1.OnDemandDocument {\n  static is(value) {\n    return value instanceof MongoDBResponse;\n  }\n  /** Indicates this document is a server error */\n  get isError() {\n    let isError = this.ok === 0;\n    isError || (isError = this.has('errmsg'));\n    isError || (isError = this.has('code'));\n    isError || (isError = this.has('$err')); // The '$err' field is used in OP_REPLY responses\n    return isError;\n  }\n  /**\n   * Drivers can safely assume that the `recoveryToken` field is always a BSON document but drivers MUST NOT modify the\n   * contents of the document.\n   */\n  get recoveryToken() {\n    var _this$get$toObject, _this$get;\n    return (_this$get$toObject = (_this$get = this.get('recoveryToken', bson_1.BSONType.object)) === null || _this$get === void 0 ? void 0 : _this$get.toObject({\n      promoteValues: false,\n      promoteLongs: false,\n      promoteBuffers: false\n    })) !== null && _this$get$toObject !== void 0 ? _this$get$toObject : null;\n  }\n  /**\n   * The server creates a cursor in response to a snapshot find/aggregate command and reports atClusterTime within the cursor field in the response.\n   * For the distinct command the server adds a top-level atClusterTime field to the response.\n   * The atClusterTime field represents the timestamp of the read and is guaranteed to be majority committed.\n   */\n  get atClusterTime() {\n    var _this$get$get, _this$get2;\n    return (_this$get$get = (_this$get2 = this.get('cursor', bson_1.BSONType.object)) === null || _this$get2 === void 0 ? void 0 : _this$get2.get('atClusterTime', bson_1.BSONType.timestamp)) !== null && _this$get$get !== void 0 ? _this$get$get : this.get('atClusterTime', bson_1.BSONType.timestamp);\n  }\n  get operationTime() {\n    return this.get('operationTime', bson_1.BSONType.timestamp);\n  }\n  get ok() {\n    return this.getNumber('ok') ? 1 : 0;\n  }\n  get $err() {\n    return this.get('$err', bson_1.BSONType.string);\n  }\n  get errmsg() {\n    return this.get('errmsg', bson_1.BSONType.string);\n  }\n  get code() {\n    return this.getNumber('code');\n  }\n  get $clusterTime() {\n    var _this$clusterTime;\n    if (!('clusterTime' in this)) {\n      var _clusterTimeDoc$get;\n      const clusterTimeDoc = this.get('$clusterTime', bson_1.BSONType.object);\n      if (clusterTimeDoc == null) {\n        this.clusterTime = null;\n        return null;\n      }\n      const clusterTime = clusterTimeDoc.get('clusterTime', bson_1.BSONType.timestamp, true);\n      const signature = (_clusterTimeDoc$get = clusterTimeDoc.get('signature', bson_1.BSONType.object)) === null || _clusterTimeDoc$get === void 0 ? void 0 : _clusterTimeDoc$get.toObject();\n      // @ts-expect-error: `signature` is incorrectly typed. It is public API.\n      this.clusterTime = {\n        clusterTime,\n        signature\n      };\n    }\n    return (_this$clusterTime = this.clusterTime) !== null && _this$clusterTime !== void 0 ? _this$clusterTime : null;\n  }\n  toObject(options) {\n    var _options$raw, _options$fieldsAsRaw;\n    const exactBSONOptions = {\n      useBigInt64: options === null || options === void 0 ? void 0 : options.useBigInt64,\n      promoteLongs: options === null || options === void 0 ? void 0 : options.promoteLongs,\n      promoteValues: options === null || options === void 0 ? void 0 : options.promoteValues,\n      promoteBuffers: options === null || options === void 0 ? void 0 : options.promoteBuffers,\n      bsonRegExp: options === null || options === void 0 ? void 0 : options.bsonRegExp,\n      raw: (_options$raw = options === null || options === void 0 ? void 0 : options.raw) !== null && _options$raw !== void 0 ? _options$raw : false,\n      fieldsAsRaw: (_options$fieldsAsRaw = options === null || options === void 0 ? void 0 : options.fieldsAsRaw) !== null && _options$fieldsAsRaw !== void 0 ? _options$fieldsAsRaw : {},\n      validation: this.parseBsonSerializationOptions(options)\n    };\n    return super.toObject(exactBSONOptions);\n  }\n  parseBsonSerializationOptions(options) {\n    const enableUtf8Validation = options === null || options === void 0 ? void 0 : options.enableUtf8Validation;\n    if (enableUtf8Validation === false) {\n      return {\n        utf8: false\n      };\n    }\n    return {\n      utf8: {\n        writeErrors: false\n      }\n    };\n  }\n}\n// {ok:1}\nMongoDBResponse.empty = new MongoDBResponse(new Uint8Array([13, 0, 0, 0, 16, 111, 107, 0, 1, 0, 0, 0, 0]));\nexports.MongoDBResponse = MongoDBResponse;\n/** @internal */\nclass CursorResponse extends MongoDBResponse {\n  static is(value) {\n    return value instanceof CursorResponse || value === CursorResponse.emptyGetMore;\n  }\n  constructor(bytes, offset, isArray) {\n    super(bytes, offset, isArray);\n    this.ns = null;\n    this.batchSize = 0;\n    this.iterated = 0;\n    const cursor = this.get('cursor', bson_1.BSONType.object, true);\n    const id = cursor.get('id', bson_1.BSONType.long, true);\n    this.id = new bson_1.Long(Number(id & 0xffffffffn), Number(id >> 32n & 0xffffffffn));\n    const namespace = cursor.get('ns', bson_1.BSONType.string);\n    if (namespace != null) this.ns = (0, utils_1.ns)(namespace);\n    if (cursor.has('firstBatch')) this.batch = cursor.get('firstBatch', bson_1.BSONType.array, true);else if (cursor.has('nextBatch')) this.batch = cursor.get('nextBatch', bson_1.BSONType.array, true);else throw new error_1.MongoUnexpectedServerResponseError('Cursor document did not contain a batch');\n    this.batchSize = this.batch.size();\n  }\n  get length() {\n    return Math.max(this.batchSize - this.iterated, 0);\n  }\n  shift(options) {\n    var _this$batch$get;\n    if (this.iterated >= this.batchSize) {\n      return null;\n    }\n    const result = (_this$batch$get = this.batch.get(this.iterated, bson_1.BSONType.object, true)) !== null && _this$batch$get !== void 0 ? _this$batch$get : null;\n    this.iterated += 1;\n    if (options !== null && options !== void 0 && options.raw) {\n      return result.toBytes();\n    } else {\n      return result.toObject(options);\n    }\n  }\n  clear() {\n    this.iterated = this.batchSize;\n  }\n  pushMany() {\n    throw new Error('pushMany Unsupported method');\n  }\n  push() {\n    throw new Error('push Unsupported method');\n  }\n}\n/**\n * This supports a feature of the FindCursor.\n * It is an optimization to avoid an extra getMore when the limit has been reached\n */\nCursorResponse.emptyGetMore = {\n  id: new bson_1.Long(0),\n  length: 0,\n  shift: () => null\n};\nexports.CursorResponse = CursorResponse;","map":{"version":3,"names":["bson_1","require","error_1","utils_1","document_1","isErrorResponse","bson","elements","parseToElementsToArray","eIdx","length","element","nameOffset","valueOffset","valueLength","i","exports","MongoDBResponse","OnDemandDocument","is","value","isError","ok","has","recoveryToken","_this$get$toObject","_this$get","get","BSONType","object","toObject","promoteValues","promoteLongs","promoteBuffers","atClusterTime","_this$get$get","_this$get2","timestamp","operationTime","getNumber","$err","string","errmsg","code","$clusterTime","_this$clusterTime","_clusterTimeDoc$get","clusterTimeDoc","clusterTime","signature","options","_options$raw","_options$fieldsAsRaw","exactBSONOptions","useBigInt64","bsonRegExp","raw","fieldsAsRaw","validation","parseBsonSerializationOptions","enableUtf8Validation","utf8","writeErrors","empty","Uint8Array","CursorResponse","emptyGetMore","constructor","bytes","offset","isArray","ns","batchSize","iterated","cursor","id","long","Long","Number","namespace","batch","array","MongoUnexpectedServerResponseError","size","Math","max","shift","_this$batch$get","result","toBytes","clear","pushMany","Error","push"],"sources":["/Users/Regan/Documents/GitHub/BadBank/node_modules/mongodb/src/cmap/wire_protocol/responses.ts"],"sourcesContent":["import {\n  type BSONSerializeOptions,\n  BSONType,\n  type Document,\n  Long,\n  parseToElementsToArray,\n  type Timestamp\n} from '../../bson';\nimport { MongoUnexpectedServerResponseError } from '../../error';\nimport { type ClusterTime } from '../../sdam/common';\nimport { type MongoDBNamespace, ns } from '../../utils';\nimport { OnDemandDocument } from './on_demand/document';\n\n// eslint-disable-next-line no-restricted-syntax\nconst enum BSONElementOffset {\n  type = 0,\n  nameOffset = 1,\n  nameLength = 2,\n  offset = 3,\n  length = 4\n}\n/**\n * Accepts a BSON payload and checks for na \"ok: 0\" element.\n * This utility is intended to prevent calling response class constructors\n * that expect the result to be a success and demand certain properties to exist.\n *\n * For example, a cursor response always expects a cursor embedded document.\n * In order to write the class such that the properties reflect that assertion (non-null)\n * we cannot invoke the subclass constructor if the BSON represents an error.\n *\n * @param bytes - BSON document returned from the server\n */\nexport function isErrorResponse(bson: Uint8Array): boolean {\n  const elements = parseToElementsToArray(bson, 0);\n  for (let eIdx = 0; eIdx < elements.length; eIdx++) {\n    const element = elements[eIdx];\n\n    if (element[BSONElementOffset.nameLength] === 2) {\n      const nameOffset = element[BSONElementOffset.nameOffset];\n\n      // 111 == \"o\", 107 == \"k\"\n      if (bson[nameOffset] === 111 && bson[nameOffset + 1] === 107) {\n        const valueOffset = element[BSONElementOffset.offset];\n        const valueLength = element[BSONElementOffset.length];\n\n        // If any byte in the length of the ok number (works for any type) is non zero,\n        // then it is considered \"ok: 1\"\n        for (let i = valueOffset; i < valueOffset + valueLength; i++) {\n          if (bson[i] !== 0x00) return false;\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return true;\n}\n\n/** @internal */\nexport type MongoDBResponseConstructor = {\n  new (bson: Uint8Array, offset?: number, isArray?: boolean): MongoDBResponse;\n};\n\n/** @internal */\nexport class MongoDBResponse extends OnDemandDocument {\n  static is(value: unknown): value is MongoDBResponse {\n    return value instanceof MongoDBResponse;\n  }\n\n  // {ok:1}\n  static empty = new MongoDBResponse(new Uint8Array([13, 0, 0, 0, 16, 111, 107, 0, 1, 0, 0, 0, 0]));\n\n  /** Indicates this document is a server error */\n  public get isError() {\n    let isError = this.ok === 0;\n    isError ||= this.has('errmsg');\n    isError ||= this.has('code');\n    isError ||= this.has('$err'); // The '$err' field is used in OP_REPLY responses\n    return isError;\n  }\n\n  /**\n   * Drivers can safely assume that the `recoveryToken` field is always a BSON document but drivers MUST NOT modify the\n   * contents of the document.\n   */\n  get recoveryToken(): Document | null {\n    return (\n      this.get('recoveryToken', BSONType.object)?.toObject({\n        promoteValues: false,\n        promoteLongs: false,\n        promoteBuffers: false\n      }) ?? null\n    );\n  }\n\n  /**\n   * The server creates a cursor in response to a snapshot find/aggregate command and reports atClusterTime within the cursor field in the response.\n   * For the distinct command the server adds a top-level atClusterTime field to the response.\n   * The atClusterTime field represents the timestamp of the read and is guaranteed to be majority committed.\n   */\n  public get atClusterTime(): Timestamp | null {\n    return (\n      this.get('cursor', BSONType.object)?.get('atClusterTime', BSONType.timestamp) ??\n      this.get('atClusterTime', BSONType.timestamp)\n    );\n  }\n\n  public get operationTime(): Timestamp | null {\n    return this.get('operationTime', BSONType.timestamp);\n  }\n\n  public get ok(): 0 | 1 {\n    return this.getNumber('ok') ? 1 : 0;\n  }\n\n  public get $err(): string | null {\n    return this.get('$err', BSONType.string);\n  }\n\n  public get errmsg(): string | null {\n    return this.get('errmsg', BSONType.string);\n  }\n\n  public get code(): number | null {\n    return this.getNumber('code');\n  }\n\n  private clusterTime?: ClusterTime | null;\n  public get $clusterTime(): ClusterTime | null {\n    if (!('clusterTime' in this)) {\n      const clusterTimeDoc = this.get('$clusterTime', BSONType.object);\n      if (clusterTimeDoc == null) {\n        this.clusterTime = null;\n        return null;\n      }\n      const clusterTime = clusterTimeDoc.get('clusterTime', BSONType.timestamp, true);\n      const signature = clusterTimeDoc.get('signature', BSONType.object)?.toObject();\n      // @ts-expect-error: `signature` is incorrectly typed. It is public API.\n      this.clusterTime = { clusterTime, signature };\n    }\n    return this.clusterTime ?? null;\n  }\n\n  public override toObject(options?: BSONSerializeOptions): Record<string, any> {\n    const exactBSONOptions = {\n      useBigInt64: options?.useBigInt64,\n      promoteLongs: options?.promoteLongs,\n      promoteValues: options?.promoteValues,\n      promoteBuffers: options?.promoteBuffers,\n      bsonRegExp: options?.bsonRegExp,\n      raw: options?.raw ?? false,\n      fieldsAsRaw: options?.fieldsAsRaw ?? {},\n      validation: this.parseBsonSerializationOptions(options)\n    };\n    return super.toObject(exactBSONOptions);\n  }\n\n  private parseBsonSerializationOptions(options?: { enableUtf8Validation?: boolean }): {\n    utf8: { writeErrors: false } | false;\n  } {\n    const enableUtf8Validation = options?.enableUtf8Validation;\n    if (enableUtf8Validation === false) {\n      return { utf8: false };\n    }\n    return { utf8: { writeErrors: false } };\n  }\n}\n\n/** @internal */\nexport class CursorResponse extends MongoDBResponse {\n  /**\n   * This supports a feature of the FindCursor.\n   * It is an optimization to avoid an extra getMore when the limit has been reached\n   */\n  static emptyGetMore = { id: new Long(0), length: 0, shift: () => null };\n\n  static override is(value: unknown): value is CursorResponse {\n    return value instanceof CursorResponse || value === CursorResponse.emptyGetMore;\n  }\n\n  public id: Long;\n  public ns: MongoDBNamespace | null = null;\n  public batchSize = 0;\n\n  private batch: OnDemandDocument;\n  private iterated = 0;\n\n  constructor(bytes: Uint8Array, offset?: number, isArray?: boolean) {\n    super(bytes, offset, isArray);\n\n    const cursor = this.get('cursor', BSONType.object, true);\n\n    const id = cursor.get('id', BSONType.long, true);\n    this.id = new Long(Number(id & 0xffff_ffffn), Number((id >> 32n) & 0xffff_ffffn));\n\n    const namespace = cursor.get('ns', BSONType.string);\n    if (namespace != null) this.ns = ns(namespace);\n\n    if (cursor.has('firstBatch')) this.batch = cursor.get('firstBatch', BSONType.array, true);\n    else if (cursor.has('nextBatch')) this.batch = cursor.get('nextBatch', BSONType.array, true);\n    else throw new MongoUnexpectedServerResponseError('Cursor document did not contain a batch');\n\n    this.batchSize = this.batch.size();\n  }\n\n  get length() {\n    return Math.max(this.batchSize - this.iterated, 0);\n  }\n\n  shift(options?: BSONSerializeOptions): any {\n    if (this.iterated >= this.batchSize) {\n      return null;\n    }\n\n    const result = this.batch.get(this.iterated, BSONType.object, true) ?? null;\n    this.iterated += 1;\n\n    if (options?.raw) {\n      return result.toBytes();\n    } else {\n      return result.toObject(options);\n    }\n  }\n\n  clear() {\n    this.iterated = this.batchSize;\n  }\n\n  pushMany() {\n    throw new Error('pushMany Unsupported method');\n  }\n\n  push() {\n    throw new Error('push Unsupported method');\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}