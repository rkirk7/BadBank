{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = void 0;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst server_selection_1 = require(\"../sdam/server_selection\");\nconst utils_1 = require(\"../utils\");\nconst operation_1 = require(\"./operation\");\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * Allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided.\n *\n * The expectation is that this function:\n * - Connects the MongoClient if it has not already been connected\n * - Creates a session if none is provided and cleans up the session it creates\n * - Selects a server based on readPreference or various factors\n * - Retries an operation if it fails for certain errors, see {@link retryOperation}\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param client - The MongoClient to execute this operation with\n * @param operation - The operation to execute\n */\nasync function executeOperation(client, operation) {\n  var _session, _operation$readPrefer, _session2, _session3;\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n  if (client.topology == null) {\n    // Auto connect on operation\n    if (client.s.hasBeenClosed) {\n      throw new error_1.MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n    try {\n      await client.connect();\n    } finally {\n      delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n    }\n  }\n  const {\n    topology\n  } = client;\n  if (topology == null) {\n    throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');\n  }\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner;\n  if (session == null) {\n    owner = Symbol();\n    session = client.startSession({\n      owner,\n      explicit: false\n    });\n  } else if (session.hasEnded) {\n    throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');\n  } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n    throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n  } else if (session.client !== client) {\n    throw new error_1.MongoInvalidArgumentError('ClientSession must be from the same MongoClient');\n  }\n  if (session.explicit && ((_session = session) === null || _session === void 0 ? void 0 : _session.timeoutMS) != null && operation.options.timeoutMS != null) {\n    throw new error_1.MongoInvalidArgumentError('Do not specify timeoutMS on operation if already specified on an explicit session');\n  }\n  const readPreference = (_operation$readPrefer = operation.readPreference) !== null && _operation$readPrefer !== void 0 ? _operation$readPrefer : read_preference_1.ReadPreference.primary;\n  const inTransaction = !!((_session2 = session) !== null && _session2 !== void 0 && _session2.inTransaction());\n  const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary) && (hasReadAspect || operation.commandName === 'runCommand')) {\n    throw new error_1.MongoTransactionError(\"Read preference in a transaction must be primary, not: \".concat(readPreference.mode));\n  }\n  if ((_session3 = session) !== null && _session3 !== void 0 && _session3.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n  let selector;\n  if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n    var _operation$server;\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = (0, server_selection_1.sameServerSelector)((_operation$server = operation.server) === null || _operation$server === void 0 ? void 0 : _operation$server.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n  const server = await topology.selectServer(selector, {\n    session,\n    operationName: operation.commandName\n  });\n  if (session == null) {\n    // No session also means it is not retryable, early exit\n    return await operation.execute(server, undefined);\n  }\n  if (!operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n    // non-retryable operation, early exit\n    try {\n      return await operation.execute(server, session);\n    } finally {\n      var _session4;\n      if (((_session4 = session) === null || _session4 === void 0 ? void 0 : _session4.owner) != null && session.owner === owner) {\n        try {\n          await session.endSession();\n        } catch (error) {\n          (0, utils_1.squashError)(error);\n        }\n      }\n    }\n  }\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n  const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n  const willRetry = hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite;\n  if (hasWriteAspect && willRetryWrite) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n  try {\n    return await operation.execute(server, session);\n  } catch (operationError) {\n    if (willRetry && operationError instanceof error_1.MongoError) {\n      return await retryOperation(operation, operationError, {\n        session,\n        topology,\n        selector,\n        previousServer: server.description\n      });\n    }\n    throw operationError;\n  } finally {\n    var _session5;\n    if (((_session5 = session) === null || _session5 === void 0 ? void 0 : _session5.owner) != null && session.owner === owner) {\n      try {\n        await session.endSession();\n      } catch (error) {\n        (0, utils_1.squashError)(error);\n      }\n    }\n  }\n}\nexports.executeOperation = executeOperation;\nasync function retryOperation(operation, originalError, _ref) {\n  let {\n    session,\n    topology,\n    selector,\n    previousServer\n  } = _ref;\n  const isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n  const isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n    throw new error_1.MongoServerError({\n      message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n      errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n      originalError\n    });\n  }\n  if (isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError)) {\n    throw originalError;\n  }\n  if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {\n    throw originalError;\n  }\n  if (originalError instanceof error_1.MongoNetworkError && session.isPinned && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n    // If we have a cursor and the initial command fails with a network error,\n    // we can retry it on another connection. So we need to check it back in, clear the\n    // pool for the service id, and retry again.\n    session.unpin({\n      force: true,\n      forceClear: true\n    });\n  }\n  // select a new server, and attempt to retry the operation\n  const server = await topology.selectServer(selector, {\n    session,\n    operationName: operation.commandName,\n    previousServer\n  });\n  if (isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {\n    throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');\n  }\n  try {\n    return await operation.execute(server, session);\n  } catch (retryError) {\n    if (retryError instanceof error_1.MongoError && retryError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {\n      throw originalError;\n    }\n    throw retryError;\n  }\n}","map":{"version":3,"names":["error_1","require","read_preference_1","server_selection_1","utils_1","operation_1","MMAPv1_RETRY_WRITES_ERROR_CODE","MONGODB_ERROR_CODES","IllegalOperation","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","executeOperation","client","operation","_session","_operation$readPrefer","_session2","_session3","AbstractOperation","MongoRuntimeError","topology","s","hasBeenClosed","MongoNotConnectedError","options","Symbol","for","connect","session","owner","startSession","explicit","hasEnded","MongoExpiredSessionError","snapshotEnabled","capabilities","supportsSnapshotReads","MongoCompatibilityError","MongoInvalidArgumentError","timeoutMS","readPreference","ReadPreference","primary","inTransaction","hasReadAspect","hasAspect","Aspect","READ_OPERATION","hasWriteAspect","WRITE_OPERATION","equals","commandName","MongoTransactionError","concat","mode","isPinned","transaction","isCommitted","bypassPinningCheck","unpin","selector","MUST_SELECT_SAME_SERVER","_operation$server","sameServerSelector","server","description","trySecondaryWrite","secondaryWritableServerSelector","commonWireVersion","selectServer","operationName","execute","undefined","RETRYABLE","_session4","endSession","error","squashError","willRetryRead","retryReads","canRetryRead","willRetryWrite","retryWrites","supportsRetryableWrites","canRetryWrite","willRetry","incrementTransactionNumber","operationError","MongoError","retryOperation","previousServer","_session5","exports","originalError","_ref","isWriteOperation","isReadOperation","code","MongoServerError","message","errmsg","isRetryableWriteError","isRetryableReadError","MongoNetworkError","CURSOR_CREATING","force","forceClear","MongoUnexpectedServerResponseError","retryError","hasErrorLabel","MongoErrorLabel","NoWritesPerformed"],"sources":["/Users/Regan/Documents/GitHub/BadBank/node_modules/mongodb/src/operations/execute_operation.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport { type CursorResponse } from '../cmap/wire_protocol/responses';\nimport {\n  isRetryableReadError,\n  isRetryableWriteError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  MongoError,\n  MongoErrorLabel,\n  MongoExpiredSessionError,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoNotConnectedError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError,\n  MongoUnexpectedServerResponseError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { ReadPreference } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport type { ServerDescription } from '../sdam/server_description';\nimport {\n  sameServerSelector,\n  secondaryWritableServerSelector,\n  type ServerSelector\n} from '../sdam/server_selection';\nimport type { Topology } from '../sdam/topology';\nimport type { ClientSession } from '../sessions';\nimport { squashError, supportsRetryableWrites } from '../utils';\nimport { AbstractOperation, Aspect } from './operation';\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\ntype ResultTypeFromOperation<TOperation> = TOperation extends AbstractOperation<infer K>\n  ? K\n  : never;\n\n/** @internal */\nexport interface ExecutionResult {\n  /** The server selected for the operation */\n  server: Server;\n  /** The session used for this operation, may be implicitly created */\n  session?: ClientSession;\n  /** The raw server response for the operation */\n  response: Document | CursorResponse;\n}\n\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * Allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided.\n *\n * The expectation is that this function:\n * - Connects the MongoClient if it has not already been connected\n * - Creates a session if none is provided and cleans up the session it creates\n * - Selects a server based on readPreference or various factors\n * - Retries an operation if it fails for certain errors, see {@link retryOperation}\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param client - The MongoClient to execute this operation with\n * @param operation - The operation to execute\n */\nexport async function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T): Promise<TResult> {\n  if (!(operation instanceof AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  if (client.topology == null) {\n    // Auto connect on operation\n    if (client.s.hasBeenClosed) {\n      throw new MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n    try {\n      await client.connect();\n    } finally {\n      delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n    }\n  }\n\n  const { topology } = client;\n  if (topology == null) {\n    throw new MongoRuntimeError('client.connect did not create a topology but also did not throw');\n  }\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner: symbol | undefined;\n\n  if (session == null) {\n    owner = Symbol();\n    session = client.startSession({ owner, explicit: false });\n  } else if (session.hasEnded) {\n    throw new MongoExpiredSessionError('Use of expired sessions is not permitted');\n  } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n    throw new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n  } else if (session.client !== client) {\n    throw new MongoInvalidArgumentError('ClientSession must be from the same MongoClient');\n  }\n  if (session.explicit && session?.timeoutMS != null && operation.options.timeoutMS != null) {\n    throw new MongoInvalidArgumentError(\n      'Do not specify timeoutMS on operation if already specified on an explicit session'\n    );\n  }\n\n  const readPreference = operation.readPreference ?? ReadPreference.primary;\n  const inTransaction = !!session?.inTransaction();\n\n  const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\n\n  if (\n    inTransaction &&\n    !readPreference.equals(ReadPreference.primary) &&\n    (hasReadAspect || operation.commandName === 'runCommand')\n  ) {\n    throw new MongoTransactionError(\n      `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n    );\n  }\n\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  let selector: ReadPreference | ServerSelector;\n\n  if (operation.hasAspect(Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = sameServerSelector(operation.server?.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = secondaryWritableServerSelector(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n\n  const server = await topology.selectServer(selector, {\n    session,\n    operationName: operation.commandName\n  });\n\n  if (session == null) {\n    // No session also means it is not retryable, early exit\n    return await operation.execute(server, undefined);\n  }\n\n  if (!operation.hasAspect(Aspect.RETRYABLE)) {\n    // non-retryable operation, early exit\n    try {\n      return await operation.execute(server, session);\n    } finally {\n      if (session?.owner != null && session.owner === owner) {\n        try {\n          await session.endSession();\n        } catch (error) {\n          squashError(error);\n        }\n      }\n    }\n  }\n\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n\n  const willRetryWrite =\n    topology.s.options.retryWrites &&\n    !inTransaction &&\n    supportsRetryableWrites(server) &&\n    operation.canRetryWrite;\n\n  const willRetry = (hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite);\n\n  if (hasWriteAspect && willRetryWrite) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n\n  try {\n    return await operation.execute(server, session);\n  } catch (operationError) {\n    if (willRetry && operationError instanceof MongoError) {\n      return await retryOperation(operation, operationError, {\n        session,\n        topology,\n        selector,\n        previousServer: server.description\n      });\n    }\n    throw operationError;\n  } finally {\n    if (session?.owner != null && session.owner === owner) {\n      try {\n        await session.endSession();\n      } catch (error) {\n        squashError(error);\n      }\n    }\n  }\n}\n\n/** @internal */\ntype RetryOptions = {\n  session: ClientSession;\n  topology: Topology;\n  selector: ReadPreference | ServerSelector;\n  previousServer: ServerDescription;\n};\n\nasync function retryOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(\n  operation: T,\n  originalError: MongoError,\n  { session, topology, selector, previousServer }: RetryOptions\n): Promise<TResult> {\n  const isWriteOperation = operation.hasAspect(Aspect.WRITE_OPERATION);\n  const isReadOperation = operation.hasAspect(Aspect.READ_OPERATION);\n\n  if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n    throw new MongoServerError({\n      message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n      errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n      originalError\n    });\n  }\n\n  if (isWriteOperation && !isRetryableWriteError(originalError)) {\n    throw originalError;\n  }\n\n  if (isReadOperation && !isRetryableReadError(originalError)) {\n    throw originalError;\n  }\n\n  if (\n    originalError instanceof MongoNetworkError &&\n    session.isPinned &&\n    !session.inTransaction() &&\n    operation.hasAspect(Aspect.CURSOR_CREATING)\n  ) {\n    // If we have a cursor and the initial command fails with a network error,\n    // we can retry it on another connection. So we need to check it back in, clear the\n    // pool for the service id, and retry again.\n    session.unpin({ force: true, forceClear: true });\n  }\n\n  // select a new server, and attempt to retry the operation\n  const server = await topology.selectServer(selector, {\n    session,\n    operationName: operation.commandName,\n    previousServer\n  });\n\n  if (isWriteOperation && !supportsRetryableWrites(server)) {\n    throw new MongoUnexpectedServerResponseError(\n      'Selected server does not support retryable writes'\n    );\n  }\n\n  try {\n    return await operation.execute(server, session);\n  } catch (retryError) {\n    if (\n      retryError instanceof MongoError &&\n      retryError.hasErrorLabel(MongoErrorLabel.NoWritesPerformed)\n    ) {\n      throw originalError;\n    }\n    throw retryError;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}