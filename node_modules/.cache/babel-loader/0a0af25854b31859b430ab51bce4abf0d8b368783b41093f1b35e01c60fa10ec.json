{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OnDemandDocument = void 0;\nconst bson_1 = require(\"../../../bson\");\n/** @internal */\nclass OnDemandDocument {\n  constructor( /** BSON bytes, this document begins at offset */\n  bson) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let isArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.bson = bson;\n    this.offset = offset;\n    this.isArray = isArray;\n    /**\n     * Maps JS strings to elements and jsValues for speeding up subsequent lookups.\n     * - If `false` then name does not exist in the BSON document\n     * - If `CachedBSONElement` instance name exists\n     * - If `cache[name].value == null` jsValue has not yet been parsed\n     *   - Null/Undefined values do not get cached because they are zero-length values.\n     */\n    this.cache = Object.create(null);\n    /** Caches the index of elements that have been named */\n    this.indexFound = Object.create(null);\n    this.elements = (0, bson_1.parseToElementsToArray)(this.bson, offset);\n  }\n  /** Only supports basic latin strings */\n  isElementName(name, element) {\n    const nameLength = element[2 /* BSONElementOffset.nameLength */];\n    const nameOffset = element[1 /* BSONElementOffset.nameOffset */];\n    if (name.length !== nameLength) return false;\n    for (let i = 0; i < name.length; i++) {\n      if (this.bson[nameOffset + i] !== name.charCodeAt(i)) return false;\n    }\n    return true;\n  }\n  /**\n   * Seeks into the elements array for an element matching the given name.\n   *\n   * @remarks\n   * Caching:\n   * - Caches the existence of a property making subsequent look ups for non-existent properties return immediately\n   * - Caches names mapped to elements to avoid reiterating the array and comparing the name again\n   * - Caches the index at which an element has been found to prevent rechecking against elements already determined to belong to another name\n   *\n   * @param name - a basic latin string name of a BSON element\n   * @returns\n   */\n  getElement(name) {\n    const cachedElement = this.cache[name];\n    if (cachedElement === false) return null;\n    if (cachedElement != null) {\n      return cachedElement;\n    }\n    if (typeof name === 'number') {\n      if (this.isArray) {\n        if (name < this.elements.length) {\n          const element = this.elements[name];\n          const cachedElement = {\n            element,\n            value: undefined\n          };\n          this.cache[name] = cachedElement;\n          this.indexFound[name] = true;\n          return cachedElement;\n        } else {\n          return null;\n        }\n      } else {\n        return null;\n      }\n    }\n    for (let index = 0; index < this.elements.length; index++) {\n      const element = this.elements[index];\n      // skip this element if it has already been associated with a name\n      if (!this.indexFound[index] && this.isElementName(name, element)) {\n        const cachedElement = {\n          element,\n          value: undefined\n        };\n        this.cache[name] = cachedElement;\n        this.indexFound[index] = true;\n        return cachedElement;\n      }\n    }\n    this.cache[name] = false;\n    return null;\n  }\n  toJSValue(element, as) {\n    const type = element[0 /* BSONElementOffset.type */];\n    const offset = element[3 /* BSONElementOffset.offset */];\n    const length = element[4 /* BSONElementOffset.length */];\n    if (as !== type) {\n      return null;\n    }\n    switch (as) {\n      case bson_1.BSONType.null:\n      case bson_1.BSONType.undefined:\n        return null;\n      case bson_1.BSONType.double:\n        return (0, bson_1.getFloat64LE)(this.bson, offset);\n      case bson_1.BSONType.int:\n        return (0, bson_1.getInt32LE)(this.bson, offset);\n      case bson_1.BSONType.long:\n        return (0, bson_1.getBigInt64LE)(this.bson, offset);\n      case bson_1.BSONType.bool:\n        return Boolean(this.bson[offset]);\n      case bson_1.BSONType.objectId:\n        return new bson_1.ObjectId(this.bson.subarray(offset, offset + 12));\n      case bson_1.BSONType.timestamp:\n        return new bson_1.Timestamp((0, bson_1.getBigInt64LE)(this.bson, offset));\n      case bson_1.BSONType.string:\n        return (0, bson_1.toUTF8)(this.bson, offset + 4, offset + length - 1, false);\n      case bson_1.BSONType.binData:\n        {\n          const totalBinarySize = (0, bson_1.getInt32LE)(this.bson, offset);\n          const subType = this.bson[offset + 4];\n          if (subType === 2) {\n            const subType2BinarySize = (0, bson_1.getInt32LE)(this.bson, offset + 1 + 4);\n            if (subType2BinarySize < 0) throw new bson_1.BSONError('Negative binary type element size found for subtype 0x02');\n            if (subType2BinarySize > totalBinarySize - 4) throw new bson_1.BSONError('Binary type with subtype 0x02 contains too long binary size');\n            if (subType2BinarySize < totalBinarySize - 4) throw new bson_1.BSONError('Binary type with subtype 0x02 contains too short binary size');\n            return new bson_1.Binary(this.bson.subarray(offset + 1 + 4 + 4, offset + 1 + 4 + 4 + subType2BinarySize), 2);\n          }\n          return new bson_1.Binary(this.bson.subarray(offset + 1 + 4, offset + 1 + 4 + totalBinarySize), subType);\n        }\n      case bson_1.BSONType.date:\n        // Pretend this is correct.\n        return new Date(Number((0, bson_1.getBigInt64LE)(this.bson, offset)));\n      case bson_1.BSONType.object:\n        return new OnDemandDocument(this.bson, offset);\n      case bson_1.BSONType.array:\n        return new OnDemandDocument(this.bson, offset, true);\n      default:\n        throw new bson_1.BSONError(\"Unsupported BSON type: \".concat(as));\n    }\n  }\n  /**\n   * Returns the number of elements in this BSON document\n   */\n  size() {\n    return this.elements.length;\n  }\n  /**\n   * Checks for the existence of an element by name.\n   *\n   * @remarks\n   * Uses `getElement` with the expectation that will populate caches such that a `has` call\n   * followed by a `getElement` call will not repeat the cost paid by the first look up.\n   *\n   * @param name - element name\n   */\n  has(name) {\n    const cachedElement = this.cache[name];\n    if (cachedElement === false) return false;\n    if (cachedElement != null) return true;\n    return this.getElement(name) != null;\n  }\n  get(name, as, required) {\n    const element = this.getElement(name);\n    if (element == null) {\n      if (required === true) {\n        throw new bson_1.BSONError(\"BSON element \\\"\".concat(name, \"\\\" is missing\"));\n      } else {\n        return null;\n      }\n    }\n    if (element.value == null) {\n      const value = this.toJSValue(element.element, as);\n      if (value == null) {\n        if (required === true) {\n          throw new bson_1.BSONError(\"BSON element \\\"\".concat(name, \"\\\" is missing\"));\n        } else {\n          return null;\n        }\n      }\n      // It is important to never store null\n      element.value = value;\n    }\n    return element.value;\n  }\n  getNumber(name, required) {\n    var _ref, _ref2;\n    const maybeBool = this.get(name, bson_1.BSONType.bool);\n    const bool = maybeBool == null ? null : maybeBool ? 1 : 0;\n    const maybeLong = this.get(name, bson_1.BSONType.long);\n    const long = maybeLong == null ? null : Number(maybeLong);\n    const result = (_ref = (_ref2 = bool !== null && bool !== void 0 ? bool : long) !== null && _ref2 !== void 0 ? _ref2 : this.get(name, bson_1.BSONType.int)) !== null && _ref !== void 0 ? _ref : this.get(name, bson_1.BSONType.double);\n    if (required === true && result == null) {\n      throw new bson_1.BSONError(\"BSON element \\\"\".concat(name, \"\\\" is missing\"));\n    }\n    return result;\n  }\n  /**\n   * Deserialize this object, DOES NOT cache result so avoid multiple invocations\n   * @param options - BSON deserialization options\n   */\n  toObject(options) {\n    return bson_1.BSON.deserialize(this.bson, {\n      ...options,\n      index: this.offset,\n      allowObjectSmallerThanBufferSize: true\n    });\n  }\n  /** Returns this document's bytes only */\n  toBytes() {\n    const size = (0, bson_1.getInt32LE)(this.bson, this.offset);\n    return this.bson.subarray(this.offset, this.offset + size);\n  }\n}\nexports.OnDemandDocument = OnDemandDocument;","map":{"version":3,"names":["bson_1","require","OnDemandDocument","constructor","bson","offset","arguments","length","undefined","isArray","cache","Object","create","indexFound","elements","parseToElementsToArray","isElementName","name","element","nameLength","nameOffset","i","charCodeAt","getElement","cachedElement","value","index","toJSValue","as","type","BSONType","null","double","getFloat64LE","int","getInt32LE","long","getBigInt64LE","bool","Boolean","objectId","ObjectId","subarray","timestamp","Timestamp","string","toUTF8","binData","totalBinarySize","subType","subType2BinarySize","BSONError","Binary","date","Date","Number","object","array","concat","size","has","get","required","getNumber","_ref","_ref2","maybeBool","maybeLong","result","toObject","options","BSON","deserialize","allowObjectSmallerThanBufferSize","toBytes","exports"],"sources":["/Users/Regan/Documents/GitHub/BadBank/node_modules/mongodb/src/cmap/wire_protocol/on_demand/document.ts"],"sourcesContent":["import {\n  Binary,\n  BSON,\n  type BSONElement,\n  BSONError,\n  type BSONSerializeOptions,\n  BSONType,\n  getBigInt64LE,\n  getFloat64LE,\n  getInt32LE,\n  ObjectId,\n  parseToElementsToArray,\n  Timestamp,\n  toUTF8\n} from '../../../bson';\n\n// eslint-disable-next-line no-restricted-syntax\nconst enum BSONElementOffset {\n  type = 0,\n  nameOffset = 1,\n  nameLength = 2,\n  offset = 3,\n  length = 4\n}\n\n/** @internal */\nexport type JSTypeOf = {\n  [BSONType.null]: null;\n  [BSONType.undefined]: null;\n  [BSONType.double]: number;\n  [BSONType.int]: number;\n  [BSONType.long]: bigint;\n  [BSONType.timestamp]: Timestamp;\n  [BSONType.binData]: Binary;\n  [BSONType.bool]: boolean;\n  [BSONType.objectId]: ObjectId;\n  [BSONType.string]: string;\n  [BSONType.date]: Date;\n  [BSONType.object]: OnDemandDocument;\n  [BSONType.array]: OnDemandDocument;\n};\n\n/** @internal */\ntype CachedBSONElement = { element: BSONElement; value: any | undefined };\n\n/** @internal */\nexport class OnDemandDocument {\n  /**\n   * Maps JS strings to elements and jsValues for speeding up subsequent lookups.\n   * - If `false` then name does not exist in the BSON document\n   * - If `CachedBSONElement` instance name exists\n   * - If `cache[name].value == null` jsValue has not yet been parsed\n   *   - Null/Undefined values do not get cached because they are zero-length values.\n   */\n  private readonly cache: Record<string, CachedBSONElement | false | undefined> =\n    Object.create(null);\n  /** Caches the index of elements that have been named */\n  private readonly indexFound: Record<number, boolean> = Object.create(null);\n\n  /** All bson elements in this document */\n  private readonly elements: ReadonlyArray<BSONElement>;\n\n  constructor(\n    /** BSON bytes, this document begins at offset */\n    protected readonly bson: Uint8Array,\n    /** The start of the document */\n    private readonly offset = 0,\n    /** If this is an embedded document, indicates if this was a BSON array */\n    public readonly isArray = false\n  ) {\n    this.elements = parseToElementsToArray(this.bson, offset);\n  }\n\n  /** Only supports basic latin strings */\n  private isElementName(name: string, element: BSONElement): boolean {\n    const nameLength = element[BSONElementOffset.nameLength];\n    const nameOffset = element[BSONElementOffset.nameOffset];\n\n    if (name.length !== nameLength) return false;\n\n    for (let i = 0; i < name.length; i++) {\n      if (this.bson[nameOffset + i] !== name.charCodeAt(i)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Seeks into the elements array for an element matching the given name.\n   *\n   * @remarks\n   * Caching:\n   * - Caches the existence of a property making subsequent look ups for non-existent properties return immediately\n   * - Caches names mapped to elements to avoid reiterating the array and comparing the name again\n   * - Caches the index at which an element has been found to prevent rechecking against elements already determined to belong to another name\n   *\n   * @param name - a basic latin string name of a BSON element\n   * @returns\n   */\n  private getElement(name: string | number): CachedBSONElement | null {\n    const cachedElement = this.cache[name];\n    if (cachedElement === false) return null;\n\n    if (cachedElement != null) {\n      return cachedElement;\n    }\n\n    if (typeof name === 'number') {\n      if (this.isArray) {\n        if (name < this.elements.length) {\n          const element = this.elements[name];\n          const cachedElement = { element, value: undefined };\n          this.cache[name] = cachedElement;\n          this.indexFound[name] = true;\n          return cachedElement;\n        } else {\n          return null;\n        }\n      } else {\n        return null;\n      }\n    }\n\n    for (let index = 0; index < this.elements.length; index++) {\n      const element = this.elements[index];\n\n      // skip this element if it has already been associated with a name\n      if (!this.indexFound[index] && this.isElementName(name, element)) {\n        const cachedElement = { element, value: undefined };\n        this.cache[name] = cachedElement;\n        this.indexFound[index] = true;\n        return cachedElement;\n      }\n    }\n\n    this.cache[name] = false;\n    return null;\n  }\n\n  /**\n   * Translates BSON bytes into a javascript value. Checking `as` against the BSON element's type\n   * this methods returns the small subset of BSON types that the driver needs to function.\n   *\n   * @remarks\n   * - BSONType.null and BSONType.undefined always return null\n   * - If the type requested does not match this returns null\n   *\n   * @param element - The element to revive to a javascript value\n   * @param as - A type byte expected to be returned\n   */\n  private toJSValue<T extends keyof JSTypeOf>(element: BSONElement, as: T): JSTypeOf[T];\n  private toJSValue(element: BSONElement, as: keyof JSTypeOf): any {\n    const type = element[BSONElementOffset.type];\n    const offset = element[BSONElementOffset.offset];\n    const length = element[BSONElementOffset.length];\n\n    if (as !== type) {\n      return null;\n    }\n\n    switch (as) {\n      case BSONType.null:\n      case BSONType.undefined:\n        return null;\n      case BSONType.double:\n        return getFloat64LE(this.bson, offset);\n      case BSONType.int:\n        return getInt32LE(this.bson, offset);\n      case BSONType.long:\n        return getBigInt64LE(this.bson, offset);\n      case BSONType.bool:\n        return Boolean(this.bson[offset]);\n      case BSONType.objectId:\n        return new ObjectId(this.bson.subarray(offset, offset + 12));\n      case BSONType.timestamp:\n        return new Timestamp(getBigInt64LE(this.bson, offset));\n      case BSONType.string:\n        return toUTF8(this.bson, offset + 4, offset + length - 1, false);\n      case BSONType.binData: {\n        const totalBinarySize = getInt32LE(this.bson, offset);\n        const subType = this.bson[offset + 4];\n\n        if (subType === 2) {\n          const subType2BinarySize = getInt32LE(this.bson, offset + 1 + 4);\n          if (subType2BinarySize < 0)\n            throw new BSONError('Negative binary type element size found for subtype 0x02');\n          if (subType2BinarySize > totalBinarySize - 4)\n            throw new BSONError('Binary type with subtype 0x02 contains too long binary size');\n          if (subType2BinarySize < totalBinarySize - 4)\n            throw new BSONError('Binary type with subtype 0x02 contains too short binary size');\n          return new Binary(\n            this.bson.subarray(offset + 1 + 4 + 4, offset + 1 + 4 + 4 + subType2BinarySize),\n            2\n          );\n        }\n\n        return new Binary(\n          this.bson.subarray(offset + 1 + 4, offset + 1 + 4 + totalBinarySize),\n          subType\n        );\n      }\n      case BSONType.date:\n        // Pretend this is correct.\n        return new Date(Number(getBigInt64LE(this.bson, offset)));\n\n      case BSONType.object:\n        return new OnDemandDocument(this.bson, offset);\n      case BSONType.array:\n        return new OnDemandDocument(this.bson, offset, true);\n\n      default:\n        throw new BSONError(`Unsupported BSON type: ${as}`);\n    }\n  }\n\n  /**\n   * Returns the number of elements in this BSON document\n   */\n  public size() {\n    return this.elements.length;\n  }\n\n  /**\n   * Checks for the existence of an element by name.\n   *\n   * @remarks\n   * Uses `getElement` with the expectation that will populate caches such that a `has` call\n   * followed by a `getElement` call will not repeat the cost paid by the first look up.\n   *\n   * @param name - element name\n   */\n  public has(name: string): boolean {\n    const cachedElement = this.cache[name];\n    if (cachedElement === false) return false;\n    if (cachedElement != null) return true;\n    return this.getElement(name) != null;\n  }\n\n  /**\n   * Turns BSON element with `name` into a javascript value.\n   *\n   * @typeParam T - must be one of the supported BSON types determined by `JSTypeOf` this will determine the return type of this function.\n   * @param name - the element name\n   * @param as - the bson type expected\n   * @param required - whether or not the element is expected to exist, if true this function will throw if it is not present\n   */\n  public get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required?: false | undefined\n  ): JSTypeOf[T] | null;\n\n  /** `required` will make `get` throw if name does not exist or is null/undefined */\n  public get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required: true\n  ): JSTypeOf[T];\n\n  public get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required?: boolean\n  ): JSTypeOf[T] | null {\n    const element = this.getElement(name);\n    if (element == null) {\n      if (required === true) {\n        throw new BSONError(`BSON element \"${name}\" is missing`);\n      } else {\n        return null;\n      }\n    }\n\n    if (element.value == null) {\n      const value = this.toJSValue(element.element, as);\n      if (value == null) {\n        if (required === true) {\n          throw new BSONError(`BSON element \"${name}\" is missing`);\n        } else {\n          return null;\n        }\n      }\n      // It is important to never store null\n      element.value = value;\n    }\n\n    return element.value;\n  }\n\n  /**\n   * Supports returning int, double, long, and bool as javascript numbers\n   *\n   * @remarks\n   * **NOTE:**\n   * - Use this _only_ when you believe the potential precision loss of an int64 is acceptable\n   * - This method does not cache the result as Longs or booleans would be stored incorrectly\n   *\n   * @param name - element name\n   * @param required - throws if name does not exist\n   */\n  public getNumber<const Req extends boolean = false>(\n    name: string,\n    required?: Req\n  ): Req extends true ? number : number | null;\n  public getNumber(name: string, required: boolean): number | null {\n    const maybeBool = this.get(name, BSONType.bool);\n    const bool = maybeBool == null ? null : maybeBool ? 1 : 0;\n\n    const maybeLong = this.get(name, BSONType.long);\n    const long = maybeLong == null ? null : Number(maybeLong);\n\n    const result = bool ?? long ?? this.get(name, BSONType.int) ?? this.get(name, BSONType.double);\n\n    if (required === true && result == null) {\n      throw new BSONError(`BSON element \"${name}\" is missing`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Deserialize this object, DOES NOT cache result so avoid multiple invocations\n   * @param options - BSON deserialization options\n   */\n  public toObject(options?: BSONSerializeOptions): Record<string, any> {\n    return BSON.deserialize(this.bson, {\n      ...options,\n      index: this.offset,\n      allowObjectSmallerThanBufferSize: true\n    });\n  }\n\n  /** Returns this document's bytes only */\n  toBytes() {\n    const size = getInt32LE(this.bson, this.offset);\n    return this.bson.subarray(this.offset, this.offset + size);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}